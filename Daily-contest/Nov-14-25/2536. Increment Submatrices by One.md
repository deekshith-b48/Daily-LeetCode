# ğŸ“Š Comprehensive Solution Report: Increment Submatrices by One

---

## ğŸ“‹ Problem Summary

**Inputs**:  
- `n`: Size of nÃ—n matrix (initially filled with zeros)
- `queries`: 2D array where each query `[row1, col1, row2, col2]` represents a submatrix

**Operation**:  
For each query, add 1 to every element in the submatrix from `(row1, col1)` to `(row2, col2)` (inclusive)

**Goal**:  
Return the final matrix after processing all queries

**Output**:  
- nÃ—n integer matrix representing the result

---

## ğŸ” Key Observations and Constraints

### ğŸ¯ Critical Insights:
1. **Brute force is too slow**: For each query, updating all elements in the submatrix would be O(nÂ²) per query, leading to O(queries Ã— nÂ²) = 10â´ Ã— 500Â² = 2.5Ã—10â¹ operations - too slow
2. **2D Difference Array**: Use 2D prefix sum technique to apply range updates in O(1) per query
3. **Efficient reconstruction**: After processing all queries, reconstruct the final matrix in O(nÂ²) time

### âš ï¸ Constraints Analysis:
- **Large matrix size**: n â‰¤ 500, so nÂ² = 250,000 elements
- **Many queries**: queries.length â‰¤ 10â´
- **Edge cases**:
  - Single cell queries
  - Queries covering entire matrix
  - Overlapping queries

---

## ğŸ“š Relevant Concepts and Theory

### ğŸ” 2D Difference Array (2D Range Update)
The 2D difference array technique allows us to perform range updates in O(1) time per query, then reconstruct the final matrix in O(nÂ²) time.

**For a query `[r1, c1, r2, c2]`**, we update the difference array `diff` as follows:
- `diff[r1][c1] += 1`
- `diff[r1][c2 + 1] -= 1` (if `c2 + 1 < n`)
- `diff[r2 + 1][c1] -= 1` (if `r2 + 1 < n`)
- `diff[r2 + 1][c2 + 1] += 1` (if both `r2 + 1 < n` and `c2 + 1 < n`)

**Reconstruction**: After processing all queries, compute the 2D prefix sum of the difference array to get the final matrix.

### ğŸ“Š Mathematical Foundation
This technique is based on the inclusion-exclusion principle:
- Adding 1 to `diff[r1][c1]` affects all cells from `(r1, c1)` to `(n-1, n-1)`
- Subtracting 1 from `diff[r1][c2 + 1]` cancels the effect for columns beyond `c2`
- Subtracting 1 from `diff[r2 + 1][c1]` cancels the effect for rows beyond `r2`
- Adding 1 to `diff[r2 + 1][c2 + 1]` corrects the double subtraction

---

## ğŸ§  Logical Analysis

### âŒ Why Brute Force Fails:
- **Time Complexity**: O(queries Ã— nÂ²) = 10â´ Ã— 250,000 = 2.5Ã—10â¹ operations
- **Java can handle ~10â¸ operations per second**, so this would take ~25 seconds - too slow

### âœ… Why 2D Difference Array Works:
- **Query processing**: O(1) per query â†’ O(queries) total
- **Reconstruction**: O(nÂ²) for final matrix
- **Total Complexity**: O(queries + nÂ²) = 10â´ + 250,000 = **260,000 operations** âœ…

### ğŸ¯ Key Insight: Inclusion-Exclusion in 2D
The 2D difference array handles the rectangular range updates by marking the four corners of each query rectangle, then using 2D prefix sums to propagate the updates correctly.

---

## ğŸ¯ Effective Strategy

### ğŸ“ Plan:
1. **Initialize** difference array `diff` of size `(n+1) Ã— (n+1)` with zeros
2. **Process each query**:
   - Apply the 2D difference array update at four corners
3. **Reconstruct final matrix**:
   - Compute 2D prefix sum of the difference array
   - The resulting matrix is the answer

### ğŸ› ï¸ Design Decisions:
- **Extra row/column**: Use `(n+1) Ã— (n+1)` difference array to avoid boundary checks
- **In-place reconstruction**: Build the final matrix directly from the difference array
- **Efficient updates**: Apply all queries first, then reconstruct once

---

## ğŸ§ª Illustrative Example Walkthrough

**Example 1**: `n = 3, queries = [[1,1,2,2],[0,0,1,1]]`

### Step 1: Initialize difference array (4Ã—4)
```
diff = [
  [0,0,0,0],
  [0,0,0,0],
  [0,0,0,0],
  [0,0,0,0]
]
```

### Step 2: Process query [1,1,2,2]
- `diff[1][1] += 1` â†’ `diff[1][1] = 1`
- `diff[1][3] -= 1` â†’ `diff[1][3] = -1`
- `diff[3][1] -= 1` â†’ `diff[3][1] = -1`
- `diff[3][3] += 1` â†’ `diff[3][3] = 1`

### Step 3: Process query [0,0,1,1]
- `diff[0][0] += 1` â†’ `diff[0][0] = 1`
- `diff[0][2] -= 1` â†’ `diff[0][2] = -1`
- `diff[2][0] -= 1` â†’ `diff[2][0] = -1`
- `diff[2][2] += 1` â†’ `diff[2][2] = 1`

### Step 4: Reconstruct matrix using 2D prefix sum
Compute `mat[i][j] = diff[i][j] + mat[i-1][j] + mat[i][j-1] - mat[i-1][j-1]`

**Final matrix**: `[[1,1,0],[1,2,1],[0,1,1]]` âœ…

---

## âš¡ Optimal Approach

**2D Difference Array with Prefix Sum Reconstruction** is optimal because:
- **Time Complexity**: O(queries + nÂ²) - optimal for given constraints
- **Space Complexity**: O(nÂ²) - necessary to store the result
- **Handles all cases correctly**: Including edge cases and maximum constraints
- **Efficient for large inputs**: Works for maximum constraints

---

## ğŸ“‹ Step-by-Step Algorithm

1. **Initialize** `(n+1) Ã— (n+1)` difference array with zeros
2. **For each query `[r1, c1, r2, c2]`**:
   - `diff[r1][c1] += 1`
   - `diff[r1][c2 + 1] -= 1`
   - `diff[r2 + 1][c1] -= 1`
   - `diff[r2 + 1][c2 + 1] += 1`
3. **Reconstruct final matrix**:
   - For `i = 0 to n-1`:
     - For `j = 0 to n-1`:
       - `mat[i][j] = diff[i][j]`
       - If `i > 0`: `mat[i][j] += mat[i-1][j]`
       - If `j > 0`: `mat[i][j] += mat[i][j-1]`
       - If `i > 0 and j > 0`: `mat[i][j] -= mat[i-1][j-1]`
4. **Return** `mat`

---

## ğŸ“Š Complexity Analysis

### â±ï¸ Time Complexity: **O(queries + nÂ²)**
- **Query processing**: O(1) per query Ã— queries = O(queries)
- **Matrix reconstruction**: O(nÂ²)
- **Total**: O(10â´ + 250,000) = **260,000 operations** âœ…

### ğŸ’¾ Space Complexity: **O(nÂ²)**
- **Difference array**: (n+1)Â² = O(nÂ²)
- **Result matrix**: nÂ² = O(nÂ²)
- **Total**: O(nÂ²)

---

## ğŸ§ª Test Cases

### âœ… Basic Cases
1. **Example 1**: `n=3, queries=[[1,1,2,2],[0,0,1,1]]` â†’ `[[1,1,0],[1,2,1],[0,1,1]]`
2. **Example 2**: `n=2, queries=[[0,0,1,1]]` â†’ `[[1,1],[1,1]]`

### âš ï¸ Edge Cases
3. **Single cell queries**: `[[0,0,0,0],[1,1,1,1]]` â†’ diagonal matrix
4. **Entire matrix**: `[[0,0,n-1,n-1]]` â†’ all ones
5. **Overlapping queries**: Multiple queries on same region

### ğŸš€ Boundary Cases
6. **Maximum constraints**: n=500, queries=10â´
7. **Corner queries**: `[[0,0,0,0]]`, `[[n-1,n-1,n-1,n-1]]`

---

## ğŸ’» Final Implementation (Java)

```java
/**
 * ğŸ“Š Solution for "Increment Submatrices by One"
 * 
 * Strategy: 2D Difference Array with Prefix Sum Reconstruction
 * Time Complexity: O(queries + nÂ²)
 * Space Complexity: O(nÂ²)
 */
class Solution {
    
    /**
     * Performs range increment operations on an nÃ—n matrix and returns the result.
     * 
     * ğŸ§  Key insight: Use 2D difference array to apply range updates in O(1) per query,
     * then reconstruct the final matrix using 2D prefix sums in O(nÂ²) time.
     * 
     * ğŸ” The 2D difference array technique marks four corners of each query rectangle:
     * 1. Add 1 at top-left corner
     * 2. Subtract 1 at top-right+1 corner  
     * 3. Subtract 1 at bottom-left+1 corner
     * 4. Add 1 at bottom-right+1 corner
     * This ensures the increment is applied exactly to the intended submatrix.
     * 
     * @param n size of the nÃ—n matrix
     * @param queries list of submatrix range increment operations
     * @return final matrix after all operations
     */
    public int[][] rangeAddQueries(int n, int[][] queries) {
        // ğŸ“‹ Initialize (n+1) Ã— (n+1) difference array to avoid boundary checks
        int[][] diff = new int[n + 1][n + 1];
        
        // ğŸ” Process each query with 2D difference array updates
        for (int[] query : queries) {
            int r1 = query[0];
            int c1 = query[1];
            int r2 = query[2];
            int c2 = query[3];
            
            // ğŸ“Œ Mark four corners of the query rectangle
            diff[r1][c1] += 1;
            diff[r1][c2 + 1] -= 1;
            diff[r2 + 1][c1] -= 1;
            diff[r2 + 1][c2 + 1] += 1;
        }
        
        // ğŸ§® Reconstruct final matrix using 2D prefix sum
        int[][] mat = new int[n][n];
        
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                // ğŸ“ˆ Compute 2D prefix sum
                mat[i][j] = diff[i][j];
                if (i > 0) {
                    mat[i][j] += mat[i - 1][j];
                }
                if (j > 0) {
                    mat[i][j] += mat[i][j - 1];
                }
                if (i > 0 && j > 0) {
                    mat[i][j] -= mat[i - 1][j - 1];
                }
            }
        }
        
        return mat;
    }
}
```
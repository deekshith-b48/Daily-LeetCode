# ðŸŽ’ Comprehensive Solution Report: Ones and Zeroes

---

## ðŸ“‹ Problem Summary

**Inputs**:  
- `strs`: Array of binary strings (containing only '0' and '1')
- `m`: Maximum number of 0's allowed in the subset
- `n`: Maximum number of 1's allowed in the subset

**Goal**:  
Return the **size of the largest subset** of `strs` such that the total count of 0's â‰¤ `m` and total count of 1's â‰¤ `n`

**Output**:  
- Integer representing maximum subset size

---

## ðŸ” Key Observations and Constraints

### ðŸŽ¯ Critical Insights:
1. **0-1 Knapsack variant**: This is a 2-dimensional knapsack problem where each item (string) has two weights (0's and 1's) and value 1
2. **Subset selection**: We can either include or exclude each string
3. **Capacity constraints**: Two-dimensional capacity (m zeros, n ones)
4. **Maximization objective**: Maximize the number of strings selected

### âš ï¸ Constraints Analysis:
- **Small input size**: `strs.length â‰¤ 600`, `m, n â‰¤ 100`
- **Reasonable string length**: `strs[i].length â‰¤ 100`
- **Edge cases**:
  - All strings have only 0's or only 1's
  - `m = 0` or `n = 0` (can only select strings with no 0's or no 1's)
  - Single string arrays

---

## ðŸ“š Relevant Concepts and Theory

### ðŸ” 2D Dynamic Programming (0-1 Knapsack)
This problem is a classic **2-dimensional 0-1 knapsack** problem where:
- **Items**: Each binary string
- **Weights**: Count of 0's and 1's in each string
- **Capacity**: `m` zeros and `n` ones
- **Value**: Each string contributes value 1 (we want to maximize count)

### ðŸ“Š DP State Definition
Let `dp[i][j][k]` = maximum number of strings we can select from the first `i` strings with at most `j` zeros and `k` ones.

However, we can optimize space by using only 2D DP since we only need the previous state.

### ðŸŽ¯ Space-Optimized DP
Use `dp[j][k]` = maximum number of strings that can be selected with at most `j` zeros and `k` ones.

We iterate through strings and update the DP table in **reverse order** to avoid using the same string multiple times.

---

## ðŸ§  Logical Analysis

### âŒ Why Greedy Approaches Fail:
- **Local optimum â‰  global optimum**: Selecting strings with fewer total characters doesn't guarantee maximum count
- **Complex trade-offs**: A string with many 0's but few 1's might be better than one with balanced counts

### âœ… Why 2D DP Works:
- **Optimal substructure**: The optimal solution for capacity `(j,k)` depends on optimal solutions for smaller capacities
- **Overlapping subproblems**: Same subproblems are solved multiple times
- **Complete coverage**: All possible combinations are considered

### ðŸŽ¯ Key Insight: Reverse Iteration
When updating the DP table, we must iterate from high capacity to low capacity to ensure each string is only used once (0-1 knapsack property).

---

## ðŸŽ¯ Effective Strategy

### ðŸ“ Plan:
1. **Precompute** the count of 0's and 1's for each string
2. **Initialize** 2D DP array `dp[m+1][n+1]` with zeros
3. **For each string**:
   - Get its zero count `zeros` and one count `ones`
   - **Iterate backwards** from `m` to `zeros` and `n` to `ones`
   - Update: `dp[j][k] = max(dp[j][k], dp[j-zeros][k-ones] + 1)`
4. **Return** `dp[m][n]`

### ðŸ› ï¸ Design Decisions:
- **Space optimization**: Use 2D DP instead of 3D
- **Reverse iteration**: Prevent using the same string multiple times
- **Precomputation**: Count zeros/ones once per string

---

## ðŸ§ª Illustrative Example Walkthrough

**Example 1**: `strs = ["10","0001","111001","1","0"], m = 5, n = 3`

### Step 1: Count zeros and ones
- `"10"`: zeros=1, ones=1
- `"0001"`: zeros=3, ones=1  
- `"111001"`: zeros=2, ones=4 (invalid since ones > n=3)
- `"1"`: zeros=0, ones=1
- `"0"`: zeros=1, ones=0

### Step 2: DP table evolution

**Initial**: `dp[j][k] = 0` for all j,k

**After "10"** (1,1):
- `dp[1][1] = max(0, dp[0][0] + 1) = 1`

**After "0001"** (3,1):
- `dp[4][2] = max(0, dp[1][1] + 1) = 2`
- `dp[3][1] = 1`

**After "111001"** (2,4): Skip (ones > n)

**After "1"** (0,1):
- `dp[1][2] = max(0, dp[1][1] + 1) = 2`
- `dp[3][2] = max(2, dp[3][1] + 1) = 2`
- `dp[4][3] = max(0, dp[4][2] + 1) = 3`
- `dp[0][1] = 1`

**After "0"** (1,0):
- `dp[1][1] = max(1, dp[0][1] + 1) = 2`
- `dp[2][2] = max(0, dp[1][2] + 1) = 3`
- `dp[4][3] = max(3, dp[3][3] + 1) = 4` (if dp[3][3] was 3)

**Final result**: `dp[5][3] = 4` âœ…

---

## âš¡ Optimal Approach

**2D Dynamic Programming with Space Optimization** is optimal because:
- **Time Complexity**: O(L Ã— m Ã— n) where L = number of strings
- **Space Complexity**: O(m Ã— n)
- **Handles all cases correctly**: Including edge cases and maximum constraints
- **Efficient for given constraints**: 600 Ã— 100 Ã— 100 = 6 million operations âœ…

---

## ðŸ“‹ Step-by-Step Algorithm

1. **Initialize** `dp[m+1][n+1] = 0`
2. **For each string** in `strs`:
   - Count zeros and ones in the string
   - **If ones > n or zeros > m**: skip (can't be included in any valid subset)
   - **For j = m down to zeros**:
     - **For k = n down to ones**:
       - `dp[j][k] = max(dp[j][k], dp[j-zeros][k-ones] + 1)`
3. **Return** `dp[m][n]`

---

## ðŸ“Š Complexity Analysis

### â±ï¸ Time Complexity: **O(L Ã— m Ã— n)**
- **L**: Number of strings (â‰¤ 600)
- **m, n**: Capacity constraints (â‰¤ 100 each)
- **Total operations**: 600 Ã— 100 Ã— 100 = **6,000,000 operations** âœ…

### ðŸ’¾ Space Complexity: **O(m Ã— n)**
- **DP table**: (m+1) Ã— (n+1) integers
- **Total**: 101 Ã— 101 = **10,201 integers** âœ…

---

## ðŸ§ª Test Cases

### âœ… Basic Cases
1. **Example 1**: `["10","0001","111001","1","0"], m=5, n=3` â†’ `4`
2. **Example 2**: `["10","0","1"], m=1, n=1` â†’ `2`

### âš ï¸ Edge Cases
3. **All invalid**: `["1111"], m=1, n=1` â†’ `0`
4. **All valid**: `["0","1"], m=1, n=1` â†’ `2`
5. **m=0**: Can only select strings with no zeros â†’ `["1","11"]`
6. **n=0**: Can only select strings with no ones â†’ `["0","00"]`

### ðŸš€ Boundary Cases
7. **Maximum constraints**: 600 strings, m=n=100
8. **Long strings**: Strings of length 100 with all 0's or all 1's

---

## ðŸ’» Final Implementation (Java)

```java
/**
 * ðŸŽ’ Solution for "Ones and Zeroes"
 * 
 * Strategy: 2D Dynamic Programming (0-1 Knapsack with two constraints)
 * Time Complexity: O(L * m * n)
 * Space Complexity: O(m * n)
 */
class Solution {
    
    /**
     * Finds the size of the largest subset with at most m 0's and n 1's.
     * 
     * ðŸ§  Key insight: This is a 2-dimensional 0-1 knapsack problem where
     * each string has two "weights" (count of 0's and 1's) and value 1.
     * We use dynamic programming to find the maximum number of strings
     * that can fit within the given constraints.
     * 
     * ðŸ” The algorithm uses space-optimized DP with reverse iteration
     * to ensure each string is only used once (0-1 property).
     * 
     * @param strs array of binary strings
     * @param m maximum number of 0's allowed
     * @param n maximum number of 1's allowed
     * @return size of largest valid subset
     */
    public int findMaxForm(String[] strs, int m, int n) {
        // ðŸ“Š DP table: dp[j][k] = max strings with j zeros and k ones
        int[][] dp = new int[m + 1][n + 1];
        
        // ðŸ” Process each string
        for (String str : strs) {
            // ðŸ“ˆ Count zeros and ones in current string
            int zeros = 0, ones = 0;
            for (char c : str.toCharArray()) {
                if (c == '0') {
                    zeros++;
                } else {
                    ones++;
                }
            }
            
            // ðŸš« Skip if string exceeds individual constraints
            if (zeros > m || ones > n) {
                continue;
            }
            
            // ðŸ”™ Update DP table in reverse order (0-1 knapsack)
            for (int j = m; j >= zeros; j--) {
                for (int k = n; k >= ones; k--) {
                    // ðŸŽ¯ Choose maximum between including and excluding current string
                    dp[j][k] = Math.max(dp[j][k], dp[j - zeros][k - ones] + 1);
                }
            }
        }
        
        return dp[m][n];
    }
}
```
# ğŸ”„ Comprehensive Solution Report: Unique Length-3 Palindromic Subsequences

---

## ğŸ“‹ Problem Summary

**Input**:  
- `s`: String of lowercase English letters (3 â‰¤ length â‰¤ 10âµ)

**Goal**:  
Return the **number of unique palindromic subsequences of length 3**

**Palindromic Subsequence Structure**:  
A length-3 palindrome has the form `aba` where:
- First and third characters are the same (`a`)
- Middle character can be any character (`b`)
- Characters don't need to be consecutive in the original string

**Output**:  
- Integer representing count of unique palindromes

---

## ğŸ” Key Observations and Constraints

### ğŸ¯ Critical Insights:
1. **Fixed structure**: All length-3 palindromes are of the form `c1 + c2 + c1` where `c1, c2 âˆˆ [a-z]`
2. **Unique counting**: We need to count unique combinations, not the number of ways to form them
3. **Existence check**: For each pair `(c1, c2)`, we need to check if there exists:
   - A `c1` at some position `i`
   - A `c2` at some position `j` where `i < j`
   - Another `c1` at some position `k` where `j < k`
4. **Efficient checking**: For each character `c1`, find its first and last occurrence, then check what characters exist between them

### âš ï¸ Constraints Analysis:
- **Large input size**: `s.length â‰¤ 10âµ`
- **Alphabet size**: Only 26 lowercase letters
- **Edge cases**:
  - String with all same characters: `"aaa"` â†’ 1 palindrome (`"aaa"`)
  - String with no repeated characters: `"abc"` â†’ 0 palindromes
  - Mixed patterns with overlapping possibilities

---

## ğŸ“š Relevant Concepts and Theory

### ğŸ” Character Boundary Approach
The key insight is that for any character `c` that appears in the string:
- Find the **first occurrence** `first[c]` and **last occurrence** `last[c]`
- Any character that appears **between** `first[c]` and `last[c]` can serve as the middle character
- The number of unique middle characters between these boundaries gives the count of palindromes starting and ending with `c`

### ğŸ“Š Set-based Counting
For each character `c` that appears at least twice:
- Create a set of all characters that appear between `first[c]` and `last[c]`
- The size of this set is the number of unique palindromes with `c` as the outer characters

### ğŸ¯ Key Insight: Alphabet Limitation
Since there are only 26 possible characters, we can:
- Precompute first and last occurrence for each character
- For each character, use a boolean array or bitset to track unique middle characters
- Total complexity is O(26 Ã— n) = O(n)

---

## ğŸ§  Logical Analysis

### âŒ Why Brute Force Fails:
- **Time Complexity**: O(nÂ³) to check all triplets - too slow for n = 10âµ
- **Space Complexity**: Storing all palindromes could be large
- **Duplicate handling**: Hard to avoid counting duplicates

### âœ… Why Boundary Approach Works:
- **Optimal substructure**: For each outer character, we only care about what's between its first and last occurrence
- **Complete coverage**: All possible palindromes are captured by this approach
- **Efficient counting**: Using sets or boolean arrays avoids duplicate counting

### ğŸ¯ Key Insight: First and Last Occurrence
If a character `c` appears at positions `iâ‚, iâ‚‚, ..., iâ‚–`, then:
- The **earliest** we can place the first `c` is `iâ‚`
- The **latest** we can place the last `c` is `iâ‚–`
- Any character between `iâ‚` and `iâ‚–` can be the middle character
- This maximizes the set of possible middle characters

---

## ğŸ¯ Effective Strategy

### ğŸ“ Plan:
1. **Precompute** first and last occurrence of each character
2. **For each character `c`** that appears at least twice:
   - Find all unique characters between `first[c]` and `last[c]`
   - Add the count of unique characters to the result
3. **Return** total result

### ğŸ› ï¸ Design Decisions:
- **First/last arrays**: Use arrays of size 26 initialized to -1
- **Unique middle characters**: Use boolean array of size 26 for each outer character
- **Early termination**: Skip characters that appear less than 2 times

---

## ğŸ§ª Illustrative Example Walkthrough

**Example 1**: `s = "aabca"`

### Step 1: Find first and last occurrences
- `'a'`: first=0, last=4
- `'b'`: first=2, last=2  
- `'c'`: first=3, last=3

### Step 2: Process each character

**Character 'a'** (appears â‰¥2 times):
- Range: [0, 4]
- Characters between positions 0 and 4: `'a'` (pos 1), `'b'` (pos 2), `'c'` (pos 3)
- Unique middle characters: `{'a', 'b', 'c'}` â†’ count = 3

**Characters 'b' and 'c'**: Appear only once â†’ skip

**Result: 3** âœ…

**Example 3**: `s = "bbcbaba"`

### First/last occurrences:
- `'a'`: first=4, last=6
- `'b'`: first=0, last=5  
- `'c'`: first=2, last=2

### Process characters:

**'a'**: Range [4,6], characters between: `'b'` (pos 5) â†’ count = 1 (`"aba"`)
**'b'**: Range [0,5], characters between: `'b'` (pos 1), `'c'` (pos 2), `'b'` (pos 3), `'a'` (pos 4) â†’ unique = `{'b','c','a'}` â†’ count = 3 (`"bbb"`, `"bcb"`, `"bab"`)
**'c'**: Only once â†’ skip

**Total: 1 + 3 = 4** âœ…

---

## âš¡ Optimal Approach

**Boundary-based Character Processing** is optimal because:
- **Time Complexity**: O(26 Ã— n) = O(n) - efficient for large inputs
- **Space Complexity**: O(1) - only fixed-size arrays for 26 characters
- **Handles all cases correctly**: Including edge cases and maximum constraints
- **Simple implementation**: Easy to understand and verify

---

## ğŸ“‹ Step-by-Step Algorithm

1. **Initialize** `first[26] = -1`, `last[26] = -1`
2. **For i = 0 to n-1**:
   - If `first[s[i]] == -1`, set `first[s[i]] = i`
   - Set `last[s[i]] = i`
3. **Initialize** `result = 0`
4. **For each character c from 'a' to 'z'**:
   - If `first[c] != -1` and `last[c] > first[c]`:
     - Create boolean array `seen[26] = false`
     - For `i = first[c] + 1` to `last[c] - 1`:
       - Mark `seen[s[i]] = true`
     - Count `true` values in `seen` and add to `result`
5. **Return** `result`

---

## ğŸ“Š Complexity Analysis

### â±ï¸ Time Complexity: **O(26 Ã— n) = O(n)**
- **First/last computation**: O(n)
- **For each character**: O(n) in worst case
- **Total**: 26 Ã— O(n) = O(n)
- **For n = 10âµ**: 26 Ã— 10âµ = **2.6 million operations** âœ…

### ğŸ’¾ Space Complexity: **O(1)**
- **Fixed arrays**: `first[26]`, `last[26]`, `seen[26]`
- **Total**: O(1) constant space

---

## ğŸ§ª Test Cases

### âœ… Basic Cases
1. **Example 1**: `"aabca"` â†’ `3`
2. **Example 2**: `"adc"` â†’ `0`
3. **Example 3**: `"bbcbaba"` â†’ `4`

### âš ï¸ Edge Cases
4. **All same**: `"aaa"` â†’ `1` (`"aaa"`)
5. **No repeats**: `"abcdef"` â†’ `0`
6. **Two characters**: `"ababa"` â†’ `2` (`"aaa"`, `"aba"`)
7. **Single repeat**: `"abcda"` â†’ `3` (`"aba"`, `"aca"`, `"ada"`)

### ğŸš€ Boundary Cases
8. **Maximum length**: 10âµ characters with complex patterns
9. **Alphabet complete**: String containing all 26 letters with repeats

---

## ğŸ’» Final Implementation (Java)

```java
/**
 * ğŸ”„ Solution for "Unique Length-3 Palindromic Subsequences"
 * 
 * Strategy: Boundary-based character processing
 * Time Complexity: O(n)
 * Space Complexity: O(1)
 */
class Solution {
    
    /**
     * Counts the number of unique palindromic subsequences of length 3.
     * 
     * ğŸ§  Key insight: Every length-3 palindrome has the form "c1 + c2 + c1".
     * For each character c1 that appears at least twice, find its first and
     * last occurrence, then count unique characters that appear between them.
     * 
     * ğŸ” The algorithm precomputes first and last occurrence positions for
     * each character, then for each valid outer character, counts unique
     * middle characters in the range between first and last occurrence.
     * 
     * @param s input string of lowercase English letters
     * @return number of unique length-3 palindromic subsequences
     */
    public int countPalindromicSubsequence(String s) {
        int n = s.length();
        
        // ğŸ“ Arrays to store first and last occurrence of each character
        int[] first = new int[26];
        int[] last = new int[26];
        
        // ğŸ“ Initialize with -1 (not found)
        for (int i = 0; i < 26; i++) {
            first[i] = -1;
            last[i] = -1;
        }
        
        // ğŸ” Find first and last occurrence of each character
        for (int i = 0; i < n; i++) {
            char c = s.charAt(i);
            int idx = c - 'a';
            
            if (first[idx] == -1) {
                first[idx] = i;
            }
            last[idx] = i;
        }
        
        int result = 0;
        
        // ğŸ”„ For each possible outer character
        for (int c = 0; c < 26; c++) {
            // ğŸš« Skip characters that don't appear or appear only once
            if (first[c] == -1 || last[c] == first[c]) {
                continue;
            }
            
            // ğŸ“Š Track unique middle characters between first and last occurrence
            boolean[] seen = new boolean[26];
            
            for (int i = first[c] + 1; i < last[c]; i++) {
                seen[s.charAt(i) - 'a'] = true;
            }
            
            // ğŸ§® Count unique middle characters
            for (boolean exists : seen) {
                if (exists) {
                    result++;
                }
            }
        }
        
        return result;
    }
}
```
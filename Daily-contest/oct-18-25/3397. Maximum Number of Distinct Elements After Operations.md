# ğŸ§™â€â™‚ï¸âœ¨ Comprehensive Solution Report: Maximum Number of Distinct Elements After Operations

---

## ğŸ“‹ Problem Summary

**Inputs**:  
- `nums`: Array of `n` integers (1 â‰¤ nums[i] â‰¤ 10â¹)  
- `k`: Non-negative integer (0 â‰¤ k â‰¤ 10â¹)

**Operation**:  
- For each element, add any integer in range `[-k, k]` **at most once**
- This means each element `nums[i]` can be transformed to any value in `[nums[i] - k, nums[i] + k]`

**Goal**:  
Return the **maximum possible number of distinct elements** in the array after operations

**Output**:  
- Single integer representing maximum distinct count

---

## ğŸ” Key Observations and Constraints

### ğŸ¯ Critical Insights:
1. **Range transformation**: Each element can be mapped to any integer in its range `[nums[i] - k, nums[i] + k]`
2. **Greedy assignment**: To maximize distinct elements, we should assign the **smallest possible unused value** to each element
3. **Sorting advantage**: Processing elements in sorted order allows us to make optimal greedy choices
4. **Range overlap**: Elements with overlapping ranges can still be assigned distinct values if we choose carefully

### âš ï¸ Constraints Analysis:
- **Large input size**: `nums.length â‰¤ 10âµ`
- **Large value ranges**: `nums[i]` and `k` can be up to 10â¹
- **Edge cases**:
  - `k = 0` (no operations allowed, return count of original distinct elements)
  - All elements identical with large `k` (can create many distinct values)
  - Non-overlapping ranges (each element can be assigned independently)

---

## ğŸ“š Relevant Concepts and Theory

### ğŸ” Greedy Algorithm with Sorting
The optimal strategy is to:
1. **Sort the array** to process elements in increasing order
2. **For each element**, assign the smallest possible value that:
   - Lies within its range `[nums[i] - k, nums[i] + k]`
   - Is greater than the last assigned value (to ensure distinctness)

### ğŸ“Š Interval Assignment Strategy
For each element `nums[i]`, we want to assign a value `v` such that:
- `nums[i] - k â‰¤ v â‰¤ nums[i] + k`
- `v > last_assigned_value`

The optimal choice is: `v = max(last_assigned_value + 1, nums[i] - k)`

If this `v` is within the element's range (i.e., `v â‰¤ nums[i] + k`), then we can assign it and increment our distinct count.

### ğŸ¯ Key Insight: Left-to-Right Greedy
By processing elements in sorted order and always choosing the smallest possible valid value, we maximize the number of distinct elements we can create.

---

## ğŸ§  Logical Analysis

### âŒ Why Simple Approaches Fail:
- **Brute force assignment**: Too many possibilities to explore
- **Random assignment**: May miss optimal distinct assignments
- **Processing in original order**: May block better assignments for later elements

### âœ… Why Sorted Greedy Works:
- **Optimal substructure**: The choice for earlier elements doesn't hurt later ones when processed in sorted order
- **Greedy choice property**: Choosing the smallest possible value leaves maximum flexibility for future elements
- **Range monotonicity**: Sorting ensures that ranges are processed in a way that maintains feasibility

### ğŸ¯ Key Insight: Range Boundaries
When we sort the array, we ensure that `nums[i] â‰¤ nums[i+1]`, which means:
- The left boundary `nums[i] - k` is non-decreasing (not strictly, but generally)
- This allows us to build distinct values incrementally without backtracking

---

## ğŸ¯ Effective Strategy

### ğŸ“ Plan:
1. **Sort the input array** `nums`
2. **Initialize** `last_assigned = -infinity` and `distinct_count = 0`
3. **For each element in sorted order**:
   - Calculate the optimal assignment: `candidate = max(last_assigned + 1, nums[i] - k)`
   - If `candidate â‰¤ nums[i] + k`, then:
     - Assign this value (`last_assigned = candidate`)
     - Increment `distinct_count`
4. **Return** `distinct_count`

### ğŸ› ï¸ Design Decisions:
- **Sorting**: Essential for greedy optimality
- **Greedy assignment**: Always choose smallest possible valid value
- **Range validation**: Ensure candidate value is within element's range

---

## ğŸ§ª Illustrative Example Walkthrough

**Example 1**: `nums = [1,2,2,3,3,4], k = 2`

### Step 1: Sort array
`nums = [1,2,2,3,3,4]` (already sorted)

### Step 2: Process each element

**Element 1** (`nums[0] = 1`):
- Range: `[1-2, 1+2] = [-1, 3]`
- `last_assigned = -inf`, so `candidate = max(-inf+1, -1) = -1`
- `-1 â‰¤ 3` âœ“ â†’ assign `-1`, `distinct_count = 1`, `last_assigned = -1`

**Element 2** (`nums[1] = 2`):
- Range: `[0, 4]`
- `candidate = max(-1+1, 0) = max(0, 0) = 0`
- `0 â‰¤ 4` âœ“ â†’ assign `0`, `distinct_count = 2`, `last_assigned = 0`

**Element 3** (`nums[2] = 2`):
- Range: `[0, 4]`
- `candidate = max(0+1, 0) = 1`
- `1 â‰¤ 4` âœ“ â†’ assign `1`, `distinct_count = 3`, `last_assigned = 1`

**Element 4** (`nums[3] = 3`):
- Range: `[1, 5]`
- `candidate = max(1+1, 1) = 2`
- `2 â‰¤ 5` âœ“ â†’ assign `2`, `distinct_count = 4`, `last_assigned = 2`

**Element 5** (`nums[4] = 3`):
- Range: `[1, 5]`
- `candidate = max(2+1, 1) = 3`
- `3 â‰¤ 5` âœ“ â†’ assign `3`, `distinct_count = 5`, `last_assigned = 3`

**Element 6** (`nums[5] = 4`):
- Range: `[2, 6]`
- `candidate = max(3+1, 2) = 4`
- `4 â‰¤ 6` âœ“ â†’ assign `4`, `distinct_count = 6`, `last_assigned = 4`

**Output**: `6` âœ…

**Example 2**: `nums = [4,4,4,4], k = 1`

### Step 1: Sort array
`nums = [4,4,4,4]`

### Step 2: Process each element

**Element 1**: Range `[3,5]`, assign `3`, count=1
**Element 2**: Range `[3,5]`, assign `4`, count=2  
**Element 3**: Range `[3,5]`, assign `5`, count=3
**Element 4**: Range `[3,5]`, candidate = `6`, but `6 > 5` âœ—

**Output**: `3` âœ…

---

## âš¡ Optimal Approach

**Sorted Greedy Assignment** is optimal because:
- **Time Complexity**: O(n log n) - dominated by sorting
- **Space Complexity**: O(1) - only constant extra space
- **Handles all cases correctly**: Including edge cases and maximum constraints
- **Proven optimal**: Greedy choice leads to global optimum

---

## ğŸ“‹ Step-by-Step Algorithm

1. **Sort** the `nums` array
2. **Initialize** `last = -10Â¹â¸` (very small number) and `count = 0`
3. **For each num in nums**:
   - Calculate `candidate = max(last + 1, num - k)`
   - If `candidate <= num + k`:
     - Set `last = candidate`
     - Increment `count`
4. **Return** `count`

---

## ğŸ“Š Complexity Analysis

### â±ï¸ Time Complexity: **O(n log n)**
- **Sorting**: O(n log n)
- **Single pass**: O(n)
- **Total**: O(n log n)
- **For n = 10âµ**: ~10âµ Ã— logâ‚‚(10âµ) â‰ˆ **1.7 million operations** âœ…

### ğŸ’¾ Space Complexity: **O(1)**
- **Extra space**: Only a few variables for tracking
- **Sorting**: In-place for primitive arrays in Java âœ…

---

## ğŸ§ª Test Cases

### âœ… Basic Cases
1. **Example 1**: `[1,2,2,3,3,4], k=2` â†’ `6`
2. **Example 2**: `[4,4,4,4], k=1` â†’ `3`

### âš ï¸ Edge Cases
3. **k = 0**: `[1,2,2,3]` â†’ `3` (original distinct count)
4. **Single element**: `[5], k=10` â†’ `1`
5. **Large k**: `[1,1,1], k=100` â†’ `3` (can assign 1,2,3)
6. **Non-overlapping**: `[1,10,20], k=2` â†’ `3` (ranges don't overlap but can still assign distinct)

### ğŸš€ Boundary Cases
7. **Maximum constraints**: 10âµ elements with large values and k
8. **Minimum values**: All elements = 1, k = 0 â†’ distinct count = 1

---

## ğŸ’» Final Implementation (Java)

```java
import java.util.Arrays;

/**
 * ğŸ§™â€â™€ï¸ Solution for "Maximum Number of Distinct Elements After Operations"
 * 
 * Strategy: Sorted greedy assignment
 * Time Complexity: O(n log n)
 * Space Complexity: O(1)
 */
class Solution {
    
    /**
     * Finds the maximum number of distinct elements achievable by adding 
     * values in range [-k, k] to each element at most once.
     * 
     * ğŸ§  Key insight: Sort the array and greedily assign the smallest possible 
     * distinct value to each element. For each element, the optimal assignment 
     * is the maximum of (last_assigned + 1) and (nums[i] - k), provided it 
     * doesn't exceed (nums[i] + k).
     * 
     * ğŸ” Sorting ensures that we process elements in an order that maximizes 
     * our ability to create distinct values without blocking future assignments.
     * 
     * @param nums array of integers that can be modified
     * @param k the range of values that can be added to each element
     * @return maximum possible number of distinct elements
     */
    public int maxDistinctElements(int[] nums, int k) {
        // ğŸ“ˆ Sort the array to enable greedy processing
        Arrays.sort(nums);
        
        // ğŸ¯ Track the last assigned value and distinct count
        long lastAssigned = Long.MIN_VALUE; // Use long to avoid overflow
        int distinctCount = 0;
        
        // ğŸ” Process each element in sorted order
        for (int num : nums) {
            // ğŸ“Š Calculate the optimal candidate value
            // Must be at least (lastAssigned + 1) to ensure distinctness
            // Must be at least (num - k) to be within range
            long candidate = Math.max(lastAssigned + 1, (long) num - k);
            
            // âœ… If candidate is within the element's range, assign it
            if (candidate <= (long) num + k) {
                lastAssigned = candidate;
                distinctCount++;
            }
            // âŒ If candidate exceeds range, skip this element 
            // (cannot create a new distinct value without conflicting)
        }
        
        return distinctCount;
    }
}
```

---

## ğŸ—ºï¸ Logic Flowchart

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚           START                 â”‚
â”‚ maxDistinctElements(nums, k)    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                â”‚
                â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚      Sort nums array            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                â”‚
                â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚      lastAssigned = MIN_VALUE   â”‚
â”‚      distinctCount = 0          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                â”‚
                â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚      For each num in nums:      â”‚
â”‚        candidate = max(         â”‚
â”‚          lastAssigned + 1,      â”‚
â”‚          num - k)               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                â”‚
                â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ candidate <= num + k ?          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                â”‚
       â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
       â”‚                  â”‚
       â–¼                  â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   Assign    â”‚    â”‚     Skip         â”‚
â”‚ candidate:  â”‚    â”‚ (cannot create   â”‚
â”‚ lastAssignedâ”‚    â”‚  new distinct)   â”‚
â”‚ = candidate â”‚    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
â”‚ distinctCount++â”‚         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜          â”‚
       â”‚                  â”‚
       â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                â–¼
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚   Next element  â”‚
        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

                â”‚
                â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚      Return distinctCount       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                â”‚
                â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚             END                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---
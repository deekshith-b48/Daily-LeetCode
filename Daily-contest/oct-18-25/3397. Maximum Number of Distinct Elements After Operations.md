# 🧙‍♂️✨ Comprehensive Solution Report: Maximum Number of Distinct Elements After Operations

---

## 📋 Problem Summary

**Inputs**:  
- `nums`: Array of `n` integers (1 ≤ nums[i] ≤ 10⁹)  
- `k`: Non-negative integer (0 ≤ k ≤ 10⁹)

**Operation**:  
- For each element, add any integer in range `[-k, k]` **at most once**
- This means each element `nums[i]` can be transformed to any value in `[nums[i] - k, nums[i] + k]`

**Goal**:  
Return the **maximum possible number of distinct elements** in the array after operations

**Output**:  
- Single integer representing maximum distinct count

---

## 🔍 Key Observations and Constraints

### 🎯 Critical Insights:
1. **Range transformation**: Each element can be mapped to any integer in its range `[nums[i] - k, nums[i] + k]`
2. **Greedy assignment**: To maximize distinct elements, we should assign the **smallest possible unused value** to each element
3. **Sorting advantage**: Processing elements in sorted order allows us to make optimal greedy choices
4. **Range overlap**: Elements with overlapping ranges can still be assigned distinct values if we choose carefully

### ⚠️ Constraints Analysis:
- **Large input size**: `nums.length ≤ 10⁵`
- **Large value ranges**: `nums[i]` and `k` can be up to 10⁹
- **Edge cases**:
  - `k = 0` (no operations allowed, return count of original distinct elements)
  - All elements identical with large `k` (can create many distinct values)
  - Non-overlapping ranges (each element can be assigned independently)

---

## 📚 Relevant Concepts and Theory

### 🔍 Greedy Algorithm with Sorting
The optimal strategy is to:
1. **Sort the array** to process elements in increasing order
2. **For each element**, assign the smallest possible value that:
   - Lies within its range `[nums[i] - k, nums[i] + k]`
   - Is greater than the last assigned value (to ensure distinctness)

### 📊 Interval Assignment Strategy
For each element `nums[i]`, we want to assign a value `v` such that:
- `nums[i] - k ≤ v ≤ nums[i] + k`
- `v > last_assigned_value`

The optimal choice is: `v = max(last_assigned_value + 1, nums[i] - k)`

If this `v` is within the element's range (i.e., `v ≤ nums[i] + k`), then we can assign it and increment our distinct count.

### 🎯 Key Insight: Left-to-Right Greedy
By processing elements in sorted order and always choosing the smallest possible valid value, we maximize the number of distinct elements we can create.

---

## 🧠 Logical Analysis

### ❌ Why Simple Approaches Fail:
- **Brute force assignment**: Too many possibilities to explore
- **Random assignment**: May miss optimal distinct assignments
- **Processing in original order**: May block better assignments for later elements

### ✅ Why Sorted Greedy Works:
- **Optimal substructure**: The choice for earlier elements doesn't hurt later ones when processed in sorted order
- **Greedy choice property**: Choosing the smallest possible value leaves maximum flexibility for future elements
- **Range monotonicity**: Sorting ensures that ranges are processed in a way that maintains feasibility

### 🎯 Key Insight: Range Boundaries
When we sort the array, we ensure that `nums[i] ≤ nums[i+1]`, which means:
- The left boundary `nums[i] - k` is non-decreasing (not strictly, but generally)
- This allows us to build distinct values incrementally without backtracking

---

## 🎯 Effective Strategy

### 📝 Plan:
1. **Sort the input array** `nums`
2. **Initialize** `last_assigned = -infinity` and `distinct_count = 0`
3. **For each element in sorted order**:
   - Calculate the optimal assignment: `candidate = max(last_assigned + 1, nums[i] - k)`
   - If `candidate ≤ nums[i] + k`, then:
     - Assign this value (`last_assigned = candidate`)
     - Increment `distinct_count`
4. **Return** `distinct_count`

### 🛠️ Design Decisions:
- **Sorting**: Essential for greedy optimality
- **Greedy assignment**: Always choose smallest possible valid value
- **Range validation**: Ensure candidate value is within element's range

---

## 🧪 Illustrative Example Walkthrough

**Example 1**: `nums = [1,2,2,3,3,4], k = 2`

### Step 1: Sort array
`nums = [1,2,2,3,3,4]` (already sorted)

### Step 2: Process each element

**Element 1** (`nums[0] = 1`):
- Range: `[1-2, 1+2] = [-1, 3]`
- `last_assigned = -inf`, so `candidate = max(-inf+1, -1) = -1`
- `-1 ≤ 3` ✓ → assign `-1`, `distinct_count = 1`, `last_assigned = -1`

**Element 2** (`nums[1] = 2`):
- Range: `[0, 4]`
- `candidate = max(-1+1, 0) = max(0, 0) = 0`
- `0 ≤ 4` ✓ → assign `0`, `distinct_count = 2`, `last_assigned = 0`

**Element 3** (`nums[2] = 2`):
- Range: `[0, 4]`
- `candidate = max(0+1, 0) = 1`
- `1 ≤ 4` ✓ → assign `1`, `distinct_count = 3`, `last_assigned = 1`

**Element 4** (`nums[3] = 3`):
- Range: `[1, 5]`
- `candidate = max(1+1, 1) = 2`
- `2 ≤ 5` ✓ → assign `2`, `distinct_count = 4`, `last_assigned = 2`

**Element 5** (`nums[4] = 3`):
- Range: `[1, 5]`
- `candidate = max(2+1, 1) = 3`
- `3 ≤ 5` ✓ → assign `3`, `distinct_count = 5`, `last_assigned = 3`

**Element 6** (`nums[5] = 4`):
- Range: `[2, 6]`
- `candidate = max(3+1, 2) = 4`
- `4 ≤ 6` ✓ → assign `4`, `distinct_count = 6`, `last_assigned = 4`

**Output**: `6` ✅

**Example 2**: `nums = [4,4,4,4], k = 1`

### Step 1: Sort array
`nums = [4,4,4,4]`

### Step 2: Process each element

**Element 1**: Range `[3,5]`, assign `3`, count=1
**Element 2**: Range `[3,5]`, assign `4`, count=2  
**Element 3**: Range `[3,5]`, assign `5`, count=3
**Element 4**: Range `[3,5]`, candidate = `6`, but `6 > 5` ✗

**Output**: `3` ✅

---

## ⚡ Optimal Approach

**Sorted Greedy Assignment** is optimal because:
- **Time Complexity**: O(n log n) - dominated by sorting
- **Space Complexity**: O(1) - only constant extra space
- **Handles all cases correctly**: Including edge cases and maximum constraints
- **Proven optimal**: Greedy choice leads to global optimum

---

## 📋 Step-by-Step Algorithm

1. **Sort** the `nums` array
2. **Initialize** `last = -10¹⁸` (very small number) and `count = 0`
3. **For each num in nums**:
   - Calculate `candidate = max(last + 1, num - k)`
   - If `candidate <= num + k`:
     - Set `last = candidate`
     - Increment `count`
4. **Return** `count`

---

## 📊 Complexity Analysis

### ⏱️ Time Complexity: **O(n log n)**
- **Sorting**: O(n log n)
- **Single pass**: O(n)
- **Total**: O(n log n)
- **For n = 10⁵**: ~10⁵ × log₂(10⁵) ≈ **1.7 million operations** ✅

### 💾 Space Complexity: **O(1)**
- **Extra space**: Only a few variables for tracking
- **Sorting**: In-place for primitive arrays in Java ✅

---

## 🧪 Test Cases

### ✅ Basic Cases
1. **Example 1**: `[1,2,2,3,3,4], k=2` → `6`
2. **Example 2**: `[4,4,4,4], k=1` → `3`

### ⚠️ Edge Cases
3. **k = 0**: `[1,2,2,3]` → `3` (original distinct count)
4. **Single element**: `[5], k=10` → `1`
5. **Large k**: `[1,1,1], k=100` → `3` (can assign 1,2,3)
6. **Non-overlapping**: `[1,10,20], k=2` → `3` (ranges don't overlap but can still assign distinct)

### 🚀 Boundary Cases
7. **Maximum constraints**: 10⁵ elements with large values and k
8. **Minimum values**: All elements = 1, k = 0 → distinct count = 1

---

## 💻 Final Implementation (Java)

```java
import java.util.Arrays;

/**
 * 🧙‍♀️ Solution for "Maximum Number of Distinct Elements After Operations"
 * 
 * Strategy: Sorted greedy assignment
 * Time Complexity: O(n log n)
 * Space Complexity: O(1)
 */
class Solution {
    
    /**
     * Finds the maximum number of distinct elements achievable by adding 
     * values in range [-k, k] to each element at most once.
     * 
     * 🧠 Key insight: Sort the array and greedily assign the smallest possible 
     * distinct value to each element. For each element, the optimal assignment 
     * is the maximum of (last_assigned + 1) and (nums[i] - k), provided it 
     * doesn't exceed (nums[i] + k).
     * 
     * 🔍 Sorting ensures that we process elements in an order that maximizes 
     * our ability to create distinct values without blocking future assignments.
     * 
     * @param nums array of integers that can be modified
     * @param k the range of values that can be added to each element
     * @return maximum possible number of distinct elements
     */
    public int maxDistinctElements(int[] nums, int k) {
        // 📈 Sort the array to enable greedy processing
        Arrays.sort(nums);
        
        // 🎯 Track the last assigned value and distinct count
        long lastAssigned = Long.MIN_VALUE; // Use long to avoid overflow
        int distinctCount = 0;
        
        // 🔁 Process each element in sorted order
        for (int num : nums) {
            // 📊 Calculate the optimal candidate value
            // Must be at least (lastAssigned + 1) to ensure distinctness
            // Must be at least (num - k) to be within range
            long candidate = Math.max(lastAssigned + 1, (long) num - k);
            
            // ✅ If candidate is within the element's range, assign it
            if (candidate <= (long) num + k) {
                lastAssigned = candidate;
                distinctCount++;
            }
            // ❌ If candidate exceeds range, skip this element 
            // (cannot create a new distinct value without conflicting)
        }
        
        return distinctCount;
    }
}
```

---

## 🗺️ Logic Flowchart

```
┌─────────────────────────────────┐
│           START                 │
│ maxDistinctElements(nums, k)    │
└─────────────────────────────────┘
                │
                ▼
┌─────────────────────────────────┐
│      Sort nums array            │
└─────────────────────────────────┘
                │
                ▼
┌─────────────────────────────────┐
│      lastAssigned = MIN_VALUE   │
│      distinctCount = 0          │
└─────────────────────────────────┘
                │
                ▼
┌─────────────────────────────────┐
│      For each num in nums:      │
│        candidate = max(         │
│          lastAssigned + 1,      │
│          num - k)               │
└─────────────────────────────────┘
                │
                ▼
┌─────────────────────────────────┐
│ candidate <= num + k ?          │
└─────────────────────────────────┘
                │
       ┌────────┴─────────┐
       │                  │
       ▼                  ▼
┌─────────────┐    ┌──────────────────┐
│   Assign    │    │     Skip         │
│ candidate:  │    │ (cannot create   │
│ lastAssigned│    │  new distinct)   │
│ = candidate │    └──────────────────┘
│ distinctCount++│         │
└─────────────┘          │
       │                  │
       └────────┬─────────┘
                ▼
        ┌─────────────────┐
        │   Next element  │
        └─────────────────┘

                │
                ▼
┌─────────────────────────────────┐
│      Return distinctCount       │
└─────────────────────────────────┘
                │
                ▼
┌─────────────────────────────────┐
│             END                 │
└─────────────────────────────────┘
```

---
# ğŸ”¢ Comprehensive Solution Report: 1-bit and 2-bit Characters

---

## ğŸ“‹ Problem Summary

**Input**:  
- `bits`: Binary array ending with 0 (1 â‰¤ length â‰¤ 1000)

**Character Encoding Rules**:  
- **1-bit character**: `0`
- **2-bit character**: `10` or `11`

**Goal**:  
Return `true` if the **last character** in the decoding **must be** a 1-bit character (`0`)

**Output**:  
- Boolean value

---

## ğŸ” Key Observations and Constraints

### ğŸ¯ Critical Insights:
1. **Greedy decoding**: The array can be decoded from left to right greedily
2. **Last character constraint**: Since the array ends with `0`, the last character is either:
   - A 1-bit character (`0`), OR  
   - The second bit of a 2-bit character (`10`)
3. **Backward analysis**: We can determine the answer by analyzing from the end backward
4. **Consecutive 1s matter**: The number of consecutive 1s before the final 0 determines the result

### âš ï¸ Constraints Analysis:
- **Small input size**: `bits.length â‰¤ 1000`
- **Guaranteed ending**: Array always ends with `0`
- **Edge cases**:
  - Single element `[0]` â†’ `true`
  - Ends with `10` â†’ depends on preceding pattern
  - Multiple consecutive 1s before final 0

---

## ğŸ“š Relevant Concepts and Theory

### ğŸ” Backward Traversal Strategy
The key insight is that we only need to count the number of **consecutive 1s immediately before the final 0**.

- If there are **even number of consecutive 1s** before the final 0, then the last character is a 1-bit character
- If there are **odd number of consecutive 1s** before the final 0, then the last character is part of a 2-bit character

### ğŸ“Š Why This Works:
- Each `1` must be part of a 2-bit character (`10` or `11`)
- Consecutive 1s pair up: `11`, `11`, etc.
- If there's an odd number of 1s, the last `1` pairs with the final `0` to form `10`
- If there's an even number of 1s, all 1s pair among themselves, leaving the final `0` as a 1-bit character

---

## ğŸ§  Logical Analysis

### âœ… Why Backward Counting Works:
- **Deterministic pairing**: 1s must be paired with the next bit
- **Final 0 is fixed**: We know the array ends with 0
- **Only immediate preceding 1s matter**: 1s that are separated by 0s don't affect the final character

### ğŸ¯ Key Insight: Even/Odd Rule
Let `count` = number of consecutive 1s before the final 0:
- If `count % 2 == 0` â†’ `true` (last character is 1-bit)
- If `count % 2 == 1` â†’ `false` (last character is 2-bit)

---

## ğŸ¯ Effective Strategy

### ğŸ“ Plan:
1. **Start from the second-to-last position** (since last is always 0)
2. **Count consecutive 1s** moving backward
3. **Stop when we hit a 0** or reach the beginning
4. **Return** `true` if count is even, `false` if odd

### ğŸ› ï¸ Design Decisions:
- **Backward traversal**: More efficient than forward simulation
- **Early termination**: Stop counting when we hit a 0
- **Simple logic**: Only need to track count parity

---

## ğŸ§ª Illustrative Example Walkthrough

**Example 1**: `bits = [1,0,0]`

### Backward counting:
- Start at index 1 (second-to-last): `bits[1] = 0`
- Count of consecutive 1s = 0
- 0 is even â†’ **return true** âœ…

**Example 2**: `bits = [1,1,1,0]`

### Backward counting:
- Start at index 2: `bits[2] = 1` â†’ count = 1
- Index 1: `bits[1] = 1` â†’ count = 2  
- Index 0: `bits[0] = 1` â†’ count = 3
- Reached beginning, count = 3 (odd) â†’ **return false** âœ…

**Additional example**: `bits = [1,1,0,0]`
- Start at index 2: `bits[2] = 0` â†’ count = 0 (even) â†’ **true** âœ…

**Additional example**: `bits = [1,1,1,1,0]`
- Count = 4 consecutive 1s (even) â†’ **true** âœ…

---

## âš¡ Optimal Approach

**Backward Consecutive 1s Counting** is optimal because:
- **Time Complexity**: O(k) where k is number of trailing 1s (worst case O(n))
- **Space Complexity**: O(1) - only constant extra space
- **Handles all cases correctly**: Including edge cases and maximum constraints
- **Simple and efficient**: Minimal operations required

---

## ğŸ“‹ Step-by-Step Algorithm

1. **Initialize** `i = bits.length - 2` (second-to-last index)
2. **While** `i >= 0` and `bits[i] == 1`:
   - Decrement `i`
3. **Calculate** number of consecutive 1s: `count = (bits.length - 2) - i`
4. **Return** `(count % 2 == 0)`

Alternatively, we can just check the parity during counting:

1. **Initialize** `count = 0`
2. **For i = bits.length - 2 down to 0**:
   - If `bits[i] == 1`: `count++`
   - Else: break
3. **Return** `(count % 2 == 0)`

---

## ğŸ“Š Complexity Analysis

### â±ï¸ Time Complexity: **O(n)**
- **Worst case**: All bits except last are 1s â†’ O(n)
- **Average case**: Only count trailing 1s â†’ often O(1)
- **Total**: O(n)

### ğŸ’¾ Space Complexity: **O(1)**
- **Constant space**: Only one integer variable for counting
- **No additional data structures**: Pure array processing

---

## ğŸ§ª Test Cases

### âœ… Basic Cases
1. **Example 1**: `[1,0,0]` â†’ `true`
2. **Example 2**: `[1,1,1,0]` â†’ `false`

### âš ï¸ Edge Cases
3. **Single element**: `[0]` â†’ `true`
4. **Two elements**: `[1,0]` â†’ `false` (forms `10`)
5. **Ends with `00`**: `[1,0,0]` â†’ `true`
6. **All 1s except last**: `[1,1,1,1,0]` â†’ `true` (4 is even)

### ğŸš€ Boundary Cases
7. **Maximum length**: 1000 elements with various patterns
8. **Alternating pattern**: `[1,0,1,0,1,0]` â†’ `true` (last `10` but wait...)

Wait, let's check `[1,0,1,0,1,0]`:
- This decodes as: `10`, `10`, `10` â†’ last character is 2-bit â†’ should be `false`
- Consecutive 1s before final 0: only the `1` at index 4 â†’ count = 1 (odd) â†’ `false` âœ…

---

## ğŸ’» Final Implementation (Java)

```java
/**
 * ğŸ”¢ Solution for "1-bit and 2-bit Characters"
 * 
 * Strategy: Backward consecutive 1s counting
 * Time Complexity: O(n)
 * Space Complexity: O(1)
 */
class Solution {
    
    /**
     * Determines if the last character must be a one-bit character.
     * 
     * ğŸ§  Key insight: Count the number of consecutive 1s immediately before 
     * the final 0. If the count is even, the last character is a 1-bit character;
     * if odd, it's part of a 2-bit character (10).
     * 
     * ğŸ” The algorithm traverses backward from the second-to-last position,
     * counting consecutive 1s until it hits a 0 or reaches the beginning.
     * The parity of this count determines the result.
     * 
     * @param bits binary array ending with 0
     * @return true if last character must be a one-bit character, false otherwise
     */
    public boolean isOneBitCharacter(int[] bits) {
        // ğŸ“ Start from the second-to-last position (last is always 0)
        int count = 0;
        int i = bits.length - 2;
        
        // ğŸ”™ Count consecutive 1s moving backward
        while (i >= 0 && bits[i] == 1) {
            count++;
            i--;
        }
        
        // ğŸ§® Even count means last character is 1-bit, odd means 2-bit
        return count % 2 == 0;
    }
}
```

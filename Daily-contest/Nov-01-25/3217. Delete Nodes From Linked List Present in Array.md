# 🗑️ Comprehensive Solution Report: Delete Nodes From Linked List Present in Array

---

## 📋 Problem Summary

**Inputs**:  
- `nums`: Array of unique integers (1 ≤ nums[i] ≤ 10⁵, length up to 10⁵)
- `head`: Head of a linked list with nodes containing integers (1 ≤ node.val ≤ 10⁵)

**Operation**:  
Remove all nodes from the linked list that have values present in the `nums` array

**Goal**:  
Return the **head of the modified linked list** after deletions

**Output**:  
- Head of the resulting linked list (could be null if all nodes are removed)

---

## 🔍 Key Observations and Constraints

### 🎯 Critical Insights:
1. **Fast lookup needed**: We need to check if a node's value exists in `nums` efficiently
2. **Linked list deletion**: Standard linked list node removal with proper pointer management
3. **Head might be removed**: The new head could be different from the original head
4. **Multiple consecutive deletions**: May need to remove several nodes in a row

### ⚠️ Constraints Analysis:
- **Large input size**: Both `nums` and linked list can have up to 10⁵ elements
- **Unique values in nums**: No duplicates, so HashSet is perfect
- **Edge cases**:
  - All nodes need to be removed (return null)
  - No nodes need to be removed (return original head)
  - Head node needs to be removed
  - Empty list (though constraints guarantee at least 1 node)

---

## 📚 Relevant Concepts and Theory

### 🔍 HashSet for O(1) Lookup
Convert the `nums` array to a `HashSet` to enable O(1) average-time complexity for checking if a value should be removed.

### 📊 Linked List Deletion Pattern
Use the standard approach for linked list deletion:
- **Handle head removal separately**: Skip all leading nodes that need to be removed
- **Use previous pointer**: For remaining nodes, maintain a `prev` pointer to properly link around deleted nodes

### 🎯 Two-Phase Approach
1. **Skip leading deletions**: Move head past all nodes that need to be removed at the beginning
2. **Process remaining list**: Use current and previous pointers to handle deletions in the middle/end

---

## 🧠 Logical Analysis

### ❌ Why Naive Approach Fails:
- **O(n×m) complexity**: Checking each node value against the entire `nums` array would be too slow
- **Pointer management errors**: Forgetting to handle head removal or proper linking

### ✅ Why HashSet + Two-Phase Works:
- **Efficient lookup**: O(1) per node value check
- **Complete coverage**: Handles all deletion scenarios (head, middle, tail, consecutive)
- **Proper pointer management**: Maintains list integrity during deletions

### 🎯 Key Insight: Head Removal First
The most critical part is handling the case where the head itself needs to be removed. We must advance the head pointer until we find a node that shouldn't be removed (or reach null).

---

## 🎯 Effective Strategy

### 📝 Plan:
1. **Convert nums to HashSet** for O(1) lookup
2. **Skip leading nodes** that need to be removed:
   - While head exists and head.val is in HashSet, advance head
3. **If head is null**, return null (all nodes removed)
4. **Process remaining list**:
   - Use `current` and `prev` pointers
   - If `current.val` is in HashSet, skip it by setting `prev.next = current.next`
   - Otherwise, advance both pointers
5. **Return** the (possibly new) head

### 🛠️ Design Decisions:
- **HashSet conversion**: Essential for performance
- **Separate head handling**: Cleaner than trying to handle everything in one loop
- **Explicit null checks**: Prevent NullPointerException

---

## 🧪 Illustrative Example Walkthrough

**Example 1**: `nums = [1,2,3]`, `head = [1,2,3,4,5]`

### Step 1: Create HashSet `{1,2,3}`

### Step 2: Skip leading deletions
- `head.val = 1` ∈ HashSet → advance head to node 2
- `head.val = 2` ∈ HashSet → advance head to node 3  
- `head.val = 3` ∈ HashSet → advance head to node 4
- `head.val = 4` ∉ HashSet → stop

### Step 3: Process remaining list
- `prev = 4`, `current = 5`
- `5` ∉ HashSet → advance both pointers
- `current = null` → done

**Result: [4,5]** ✅

**Example 2**: `nums = [1]`, `head = [1,2,1,2,1,2]`

### Step 2: Skip leading deletions
- `head.val = 1` ∈ HashSet → advance to node 2
- `head.val = 2` ∉ HashSet → stop

### Step 3: Process remaining list
- Remove all subsequent `1` nodes, keep all `2` nodes
- **Result: [2,2,2]** ✅

**Example 3**: `nums = [5]`, `head = [1,2,3,4]`
- No values in HashSet match any nodes
- **Result: [1,2,3,4]** ✅

---

## ⚡ Optimal Approach

**HashSet + Two-Phase Deletion** is optimal because:
- **Time Complexity**: O(n + m) where n = list length, m = nums length
- **Space Complexity**: O(m) for HashSet
- **Handles all cases correctly**: Including edge cases and maximum constraints
- **Single pass**: Each node visited exactly once

---

## 📋 Step-by-Step Algorithm

1. **Create HashSet** from `nums` array
2. **Skip leading nodes**:
   - While `head != null` and `head.val` in HashSet: `head = head.next`
3. **If head is null**, return null
4. **Initialize pointers**: `prev = head`, `current = head.next`
5. **While current != null**:
   - If `current.val` in HashSet: `prev.next = current.next`
   - Else: `prev = current`
   - `current = current.next`
6. **Return** head

---

## 📊 Complexity Analysis

### ⏱️ Time Complexity: **O(n + m)**
- **HashSet creation**: O(m) where m = nums.length
- **List traversal**: O(n) where n = number of nodes
- **Total**: O(n + m)

### 💾 Space Complexity: **O(m)**
- **HashSet storage**: O(m) for nums array
- **Pointers**: O(1) extra space
- **Total**: O(m)

---

## 🧪 Test Cases

### ✅ Basic Cases
1. **Example 1**: `nums = [1,2,3]`, `head = [1,2,3,4,5]` → `[4,5]`
2. **Example 2**: `nums = [1]`, `head = [1,2,1,2,1,2]` → `[2,2,2]`
3. **Example 3**: `nums = [5]`, `head = [1,2,3,4]` → `[1,2,3,4]`

### ⚠️ Edge Cases
4. **All removed**: `nums = [1,2,3]`, `head = [1,2,3]` → `null`
5. **Single node removed**: `nums = [1]`, `head = [1]` → `null`
6. **Single node kept**: `nums = [2]`, `head = [1]` → `[1]`
7. **Consecutive removals**: `nums = [2]`, `head = [1,2,2,2,3]` → `[1,3]`

---

## 💻 Final Implementation (Java)

```java
import java.util.*;

/**
 * 🗑️ Solution for "Delete Nodes From Linked List Present in Array"
 * 
 * Strategy: HashSet for O(1) lookup + two-phase linked list deletion
 * Time Complexity: O(n + m)
 * Space Complexity: O(m)
 */
class Solution {
    
    /**
     * Removes all nodes from the linked list that have values present in nums array.
     * 
     * 🧠 Key insight: Use HashSet for O(1) value lookup, then handle deletions in two phases:
     * 1. Skip all leading nodes that need to be removed (handle new head)
     * 2. Process remaining list with prev/current pointers for middle/tail deletions
     * 
     * 🔍 This approach efficiently handles all edge cases including head removal,
     * consecutive deletions, and complete list removal.
     * 
     * @param nums array of unique integers to remove from linked list
     * @param head head of the input linked list
     * @return head of the modified linked list (may be null)
     */
    public ListNode modifiedList(int[] nums, ListNode head) {
        // 📋 Convert nums array to HashSet for O(1) lookup
        Set<Integer> toRemove = new HashSet<>();
        for (int num : nums) {
            toRemove.add(num);
        }
        
        // 🚫 Skip all leading nodes that need to be removed
        while (head != null && toRemove.contains(head.val)) {
            head = head.next;
        }
        
        // 🛑 If all nodes were removed, return null
        if (head == null) {
            return null;
        }
        
        // 🔗 Process remaining list with prev/current pointers
        ListNode prev = head;
        ListNode current = head.next;
        
        while (current != null) {
            if (toRemove.contains(current.val)) {
                // 🗑️ Remove current node by skipping it
                prev.next = current.next;
            } else {
                // ✅ Keep current node, advance prev pointer
                prev = current;
            }
            // 🔄 Always advance current pointer
            current = current.next;
        }
        
        return head;
    }
}
```
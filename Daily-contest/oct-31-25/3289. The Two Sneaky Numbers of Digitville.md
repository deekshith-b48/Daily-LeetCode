# 🕵️ Comprehensive Solution Report: The Two Sneaky Numbers of Digitville

---

## 📋 Problem Summary

**Inputs**:  
- `nums`: Array of integers where:
  - Expected range: `0` to `n-1` (each should appear exactly once)
  - Actual length: `n + 2` (two extra numbers sneaked in)
  - Exactly two numbers appear **twice**, all others appear exactly once

**Goal**:  
Find and return the **two sneaky numbers** that appear twice

**Output**:  
- Array of size 2 containing the two repeated numbers (in any order)

---

## 🔍 Key Observations and Constraints

### 🎯 Critical Insights:
1. **Perfect setup for counting**: We know exactly what the expected frequency should be (1 for each number 0 to n-1)
2. **Only two duplicates**: Exactly two numbers will have frequency 2, all others frequency 1
3. **Small constraints**: `n ≤ 100`, so `nums.length ≤ 102`
4. **Known range**: All numbers are in range `[0, n-1]` where `n = nums.length - 2`

### ⚠️ Constraints Analysis:
- **Small input size**: Maximum 102 elements
- **Limited value range**: Values between 0 and 99
- **Guaranteed solution**: Exactly two duplicates exist
- **Edge cases**:
  - Minimum case: `n = 2`, `nums.length = 4`, values in `[0,1]`
  - Duplicates could be any two numbers in the valid range

---

## 📚 Relevant Concepts and Theory

### 🔍 Frequency Counting
The most straightforward approach is to **count the frequency** of each number and find those with count 2.

### 📊 Boolean Tracking Alternative
Since we only care about finding duplicates (not exact counts), we can use a **boolean array** to track which numbers we've seen:
- If we encounter a number that's already marked as seen, it's a duplicate
- This saves space compared to integer counting

### 🎯 Mathematical Approach (XOR)
While XOR could theoretically work for single duplicates, with two duplicates it becomes complex and unnecessary given the small constraints.

---

## 🧠 Logical Analysis

### ✅ Why Frequency Counting Works:
- **Simple and direct**: Exactly matches the problem requirements
- **Efficient for small inputs**: O(n) time and space
- **Easy to understand and verify**: No complex logic needed

### 🎯 Key Insight: Determine n from input
Since `nums.length = n + 2`, we can compute `n = nums.length - 2`
- This gives us the expected range: `[0, n-1] = [0, nums.length - 3]`
- But actually, we don't even need to compute n explicitly since all values are guaranteed to be in the valid range

---

## 🎯 Effective Strategy

### 📝 Plan:
1. **Create frequency tracking array** (boolean or integer)
2. **Iterate through nums**:
   - For each number, check if we've seen it before
   - If yes, it's a sneaky number - add to result
3. **Return** the two sneaky numbers

### 🛠️ Design Decisions:
- **Boolean array**: More memory efficient than integer counting
- **Early termination**: Stop once we find both sneaky numbers
- **Simple logic**: No need for complex data structures

---

## 🧪 Illustrative Example Walkthrough

**Example 1**: `nums = [0,1,1,0]`
- `n = 4 - 2 = 2`, expected range `[0,1]`
- Process:
  - `0`: not seen → mark seen
  - `1`: not seen → mark seen  
  - `1`: already seen → sneaky number #1
  - `0`: already seen → sneaky number #2
- **Result: [1, 0]** (or [0, 1]) ✅

**Example 2**: `nums = [0,3,2,1,3,2]`
- `n = 6 - 2 = 4`, expected range `[0,3]`
- Process:
  - `0,3,2,1`: all new → mark seen
  - `3`: already seen → sneaky #1
  - `2`: already seen → sneaky #2
- **Result: [3, 2]** ✅

**Example 3**: `nums = [7,1,5,4,3,4,6,0,9,5,8,2]`
- `n = 12 - 2 = 10`, expected range `[0,9]`
- Duplicates: `4` and `5` appear twice
- **Result: [4, 5]** ✅

---

## ⚡ Optimal Approach

**Boolean Tracking with Early Termination** is optimal because:
- **Time Complexity**: O(n) - single pass through array
- **Space Complexity**: O(n) - boolean array of size n
- **Handles all cases correctly**: Including edge cases and maximum constraints
- **Efficient**: Stops as soon as both sneaky numbers are found

---

## 📋 Step-by-Step Algorithm

1. **Compute n**: `n = nums.length - 2`
2. **Create boolean array** `seen` of size `n` (or `n+1` to be safe)
3. **Initialize** result array and index counter
4. **For each number in nums**:
   - If `seen[number]` is true:
     - Add number to result
     - If we have found 2 numbers, break
   - Else:
     - Set `seen[number] = true`
5. **Return** result array

---

## 📊 Complexity Analysis

### ⏱️ Time Complexity: **O(n)**
- **Single pass**: Process each element at most once
- **Early termination**: May stop before processing all elements
- **Total**: O(n) where n = nums.length

### 💾 Space Complexity: **O(n)**
- **Boolean array**: Size n = nums.length - 2 ≤ 100
- **Result array**: Fixed size 2
- **Total**: O(n) which is negligible for constraints

---

## 🧪 Test Cases

### ✅ Basic Cases
1. **Example 1**: `[0,1,1,0]` → `[0,1]`
2. **Example 2**: `[0,3,2,1,3,2]` → `[2,3]`
3. **Example 3**: `[7,1,5,4,3,4,6,0,9,5,8,2]` → `[4,5]`

### ⚠️ Edge Cases
4. **Minimum size**: `[0,1,0,1]` → `[0,1]`
5. **Consecutive duplicates**: `[0,1,2,3,2,3]` → `[2,3]`
6. **Non-consecutive**: `[1,0,1,0]` → `[1,0]`

### 🚀 Boundary Cases
7. **Maximum n**: n=100, nums.length=102 with duplicates at positions 0 and 99

---

## 💻 Final Implementation (Java)

```java
/**
 * 🕵️ Solution for "The Two Sneaky Numbers of Digitville"
 * 
 * Strategy: Boolean tracking with early termination
 * Time Complexity: O(n)
 * Space Complexity: O(n)
 */
class Solution {
    
    /**
     * Finds the two sneaky numbers that appear twice in the array.
     * 
     * 🧠 Key insight: Since the array should contain numbers 0 to n-1 exactly once,
     * but has length n+2, exactly two numbers appear twice. We can use a boolean
     * array to track which numbers we've seen, and any number seen twice is sneaky.
     * 
     * 🔍 The algorithm stops as soon as both sneaky numbers are found, making it
     * efficient even for the maximum input size.
     * 
     * @param nums array containing numbers 0 to n-1 with exactly two duplicates
     * @return array of size 2 containing the two sneaky numbers
     */
    public int[] getSneakyNumbers(int[] nums) {
        // 📏 Compute n from array length: nums.length = n + 2
        int n = nums.length - 2;
        
        // 📋 Boolean array to track seen numbers
        boolean[] seen = new boolean[n + 1]; // +1 for safety, though n is sufficient
        
        // 🎯 Result array to store the two sneaky numbers
        int[] result = new int[2];
        int foundCount = 0;
        
        // 🔍 Find sneaky numbers by tracking duplicates
        for (int num : nums) {
            if (seen[num]) {
                // 🕵️ Found a sneaky number!
                result[foundCount] = num;
                foundCount++;
                
                // 🚀 Early termination: we found both sneaky numbers
                if (foundCount == 2) {
                    break;
                }
            } else {
                // ✅ Mark number as seen
                seen[num] = true;
            }
        }
        
        return result;
    }
}
```
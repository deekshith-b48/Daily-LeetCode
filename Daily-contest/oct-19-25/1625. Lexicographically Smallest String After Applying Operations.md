# üßô‚Äç‚ôÇÔ∏è‚ú® Comprehensive Solution Report: Lexicographically Smallest String After Applying Operations

---

## üìã Problem Summary

**Inputs**:  
- `s`: String of even length (2 ‚â§ length ‚â§ 100) consisting of digits '0'-'9'
- `a`: Integer (1 ‚â§ a ‚â§ 9) for adding to odd indices
- `b`: Integer (1 ‚â§ b ‚â§ length-1) for right rotation amount

**Operations** (can be applied any number of times in any order):
1. **Add operation**: Add `a` to all **odd indices** (0-indexed), with digits cycling: `(digit + a) % 10`
2. **Rotate operation**: Rotate string right by `b` positions

**Goal**:  
Return the **lexicographically smallest string** achievable through any sequence of operations

**Output**:  
- String representing the lexicographically smallest result

---

## üîç Key Observations and Constraints

### üéØ Critical Insights:
1. **Finite state space**: Since string length ‚â§ 100 and digits are 0-9, there are at most `10^100` possible strings, but the actual reachable states are much fewer due to operation constraints
2. **Rotation cycles**: Repeated rotations will eventually cycle back to the original string. The number of unique rotations is `n / gcd(n, b)`
3. **Add operation independence**: The add operation only affects odd indices, and since we can apply it multiple times, we can achieve any value `(original_digit + k*a) % 10` for odd positions
4. **Even indices constraint**: When `b` is even, rotations preserve the parity of indices, so even indices can never be modified. When `b` is odd, rotations can move even indices to odd positions, making them modifiable.

### ‚ö†Ô∏è Constraints Analysis:
- **Small string length**: ‚â§ 100 makes BFS/DFS feasible
- **Limited operations**: Only two operations with specific behaviors
- **Edge cases**:
  - `b` is even vs odd (affects which indices can be modified)
  - `a = 5` (only 2 possible values per odd index: original and original+5)
  - String already lexicographically smallest

---

## üìö Relevant Concepts and Theory

### üîç Breadth-First Search (BFS)
Since we want the lexicographically smallest string and all operations have equal "cost", we can use **BFS** to explore all reachable states level by level, keeping track of the minimum string found.

However, a more efficient approach is to use **DFS with memoization** or simply **enumerate all possible states** since the state space is manageable.

### üìä State Space Enumeration
The key insight is that:
- **Number of unique rotations**: `rotations = n / gcd(n, b)` ‚â§ 100
- **Number of add combinations**: For each odd position, we can have at most 10 different values, but since all odd positions are modified together, we only need to try 10 different add amounts (0 to 9 applications of operation 1)
- **When b is odd**: We can also apply add operations after rotations to modify originally even positions

### üéØ Mathematical Optimization
- **GCD for rotations**: The number of unique rotations is `n / gcd(n, b)`
- **Modular arithmetic**: For add operations, we only need to try `0` to `9` applications since `(digit + 10*a) % 10 = digit`

---

## üß† Logical Analysis

### ‚ùå Why Greedy Approaches Fail:
- **Operation interdependence**: The order of operations matters significantly
- **Local optimum ‚â† global optimum**: Making the string smaller at one step might prevent better improvements later
- **Complex interactions**: Rotations can bring different digits to modifiable positions

### ‚úÖ Why State Enumeration Works:
- **Bounded state space**: At most 100 rotations √ó 10 add combinations √ó (10 if b is odd) = 10,000 states maximum
- **Complete exploration**: We can systematically explore all reachable states
- **Optimal result**: By tracking the minimum string across all states, we guarantee the lexicographically smallest result

### üéØ Key Insight: Parity Matters
- **If b is even**: Rotations preserve index parity, so only original odd indices can ever be modified
- **If b is odd**: Rotations can move any index to an odd position, so all indices can potentially be modified

This means:
- **Even b**: For each rotation, we can only optimize odd positions
- **Odd b**: For each rotation, we can optimize both odd and even positions (by applying add operations at different rotation states)

---

## üéØ Effective Strategy

### üìù Plan:
1. **Generate all unique rotations** of the string (at most `n / gcd(n, b)` rotations)
2. **For each rotation**:
   - **If b is odd**: Try all 10 possible add amounts for odd positions, then for each result, try all 10 possible add amounts for even positions
   - **If b is even**: Try all 10 possible add amounts for odd positions only
3. **Track the lexicographically smallest string** across all possibilities

### üõ†Ô∏è Design Decisions:
- **GCD calculation**: Use Euclidean algorithm to find number of unique rotations
- **String rotation**: Implement efficient rotation function
- **Add operation**: Apply modulo 10 arithmetic for digit cycling
- **Lexicographic comparison**: Use built-in string comparison

---

## üß™ Illustrative Example Walkthrough

**Example 1**: `s = "5525", a = 9, b = 2`

### Step 1: Analyze parameters
- `n = 4`, `b = 2` (even), so `gcd(4, 2) = 2`
- Unique rotations: `4 / 2 = 2` rotations: `"5525"` and `"2555"`

### Step 2: Process each rotation

**Rotation 1**: `"5525"`
- Odd indices: positions 1, 3 ‚Üí digits '5', '5'
- Try add amounts 0-9:
  - Add 0: `"5525"`
  - Add 1: `"5424"` (5+9=14‚Üí4, 5+9=14‚Üí4)
  - Add 2: `"5323"`
  - ...
  - Add 5: `"5020"`
  - Best for this rotation: `"5020"`

**Rotation 2**: `"2555"`
- Odd indices: positions 1, 3 ‚Üí digits '5', '5'
- Try add amounts 0-9:
  - Add 0: `"2555"`
  - Add 1: `"2454"`
  - Add 2: `"2353"`
  - Add 3: `"2252"`
  - Add 4: `"2151"`
  - Add 5: `"2050"` ‚Üê **lexicographically smallest**
  - Add 6: `"2959"`
  - ...

**Result**: `"2050"` ‚úÖ

**Example 2**: `s = "74", a = 5, b = 1`
- `b = 1` (odd), so all positions can be modified
- Unique rotations: `gcd(2,1) = 1`, so 2 rotations: `"74"` and `"47"`
- For each rotation, try all combinations of odd and even add amounts
- Best result: `"24"` ‚úÖ

---

## ‚ö° Optimal Approach

**Complete State Enumeration** is optimal because:
- **Time Complexity**: O(n¬≤ √ó 100) = manageable for n ‚â§ 100
- **Space Complexity**: O(n √ó number_of_states) = acceptable
- **Guarantees optimal result**: Explores all reachable states
- **Handles both parity cases**: Works for both even and odd `b`

---

## üìã Step-by-Step Algorithm

1. **Initialize** `best = s`
2. **Generate all unique rotations**:
   - Start with original string
   - Keep rotating right by `b` until we cycle back
3. **For each rotation string `rot`**:
   - **If b is odd**:
     - For `add_odd = 0 to 9`:
       - Apply add operation to odd indices of `rot`
       - For `add_even = 0 to 9`:
         - Apply add operation to even indices of the result
         - Update `best` if result is lexicographically smaller
   - **If b is even**:
     - For `add_odd = 0 to 9`:
       - Apply add operation to odd indices of `rot`
       - Update `best` if result is lexicographically smaller
4. **Return** `best`

---

## üìä Complexity Analysis

### ‚è±Ô∏è Time Complexity: **O(n¬≤ √ó 100)**
- **Unique rotations**: O(n) (at most n)
- **Add combinations**: O(10) for even b, O(100) for odd b
- **String operations**: O(n) per operation
- **Total**: O(n √ó 100 √ó n) = O(100n¬≤)
- **For n = 100**: 100 √ó 100 √ó 100 = **1,000,000 operations** ‚úÖ

### üíæ Space Complexity: **O(n¬≤)**
- **Visited rotations**: O(n) strings of length n
- **Temporary strings**: O(n) per operation
- **Total**: O(n¬≤) ‚úÖ

---

## üß™ Test Cases

### ‚úÖ Basic Cases
1. **Example 1**: `"5525", a=9, b=2` ‚Üí `"2050"`
2. **Example 2**: `"74", a=5, b=1` ‚Üí `"24"`
3. **Example 3**: `"0011", a=4, b=2` ‚Üí `"0011"`

### ‚ö†Ô∏è Edge Cases
4. **b = n-1**: Maximum rotation
5. **a = 1**: Can achieve any digit value
6. **All same digits**: `"1111", a=1, b=1` ‚Üí `"0000"`
7. **Even b with odd length**: Not possible (constraint says even length)

### üöÄ Boundary Cases
8. **Maximum length**: 100 characters with complex patterns
9. **a = 5**: Only 2 possible values per position

---

## üíª Final Implementation (Java)

```java
import java.util.*;

/**
 * üßô‚Äç‚ôÄÔ∏è Solution for "Lexicographically Smallest String After Applying Operations"
 * 
 * Strategy: Complete state enumeration with rotation and add operation combinations
 * Time Complexity: O(n¬≤ √ó 100)
 * Space Complexity: O(n¬≤)
 */
class Solution {
    
    /**
     * Finds the lexicographically smallest string achievable by applying 
     * add and rotate operations any number of times.
     * 
     * üß† Key insight: The state space is bounded because:
     * 1. Rotations cycle with period n/gcd(n,b)
     * 2. Add operations on odd indices have period 10 (digits 0-9)
     * 3. When b is odd, we can also modify even indices by rotating first
     * 
     * üîç We enumerate all possible states by:
     * - Generating all unique rotations
     * - For each rotation, trying all possible add combinations
     * - Tracking the lexicographically smallest result
     * 
     * @param s input string of even length with digits 0-9
     * @param a value to add to odd indices (with modulo 10)
     * @param b rotation amount (right rotation)
     * @return lexicographically smallest achievable string
     */
    public String findLexSmallestString(String s, int a, int b) {
        int n = s.length();
        String best = s;
        
        // üîÑ Generate all unique rotations
        Set<String> visited = new HashSet<>();
        Queue<String> queue = new LinkedList<>();
        queue.offer(s);
        visited.add(s);
        
        while (!queue.isEmpty()) {
            String current = queue.poll();
            
            // üìä Try all possible add operations on this rotation
            String candidate = tryAddOperations(current, a, b);
            if (candidate.compareTo(best) < 0) {
                best = candidate;
            }
            
            // üîÑ Generate next rotation
            String rotated = rotateRight(current, b);
            if (!visited.contains(rotated)) {
                visited.add(rotated);
                queue.offer(rotated);
            }
        }
        
        return best;
    }
    
    /**
     * Applies all possible add operation combinations to a string and 
     * returns the lexicographically smallest result.
     */
    private String tryAddOperations(String s, int a, int b) {
        int n = s.length();
        String best = s;
        
        // üî¢ Try all possible add amounts for odd indices (0-9)
        for (int addOdd = 0; addOdd < 10; addOdd++) {
            StringBuilder sb = new StringBuilder(s);
            
            // Apply add operation to odd indices
            for (int i = 1; i < n; i += 2) {
                int digit = s.charAt(i) - '0';
                int newDigit = (digit + addOdd * a) % 10;
                sb.setCharAt(i, (char) ('0' + newDigit));
            }
            
            String withOdd = sb.toString();
            
            // If b is odd, we can also modify even indices by applying add operations
            // after rotations, but since we're exploring all rotations separately,
            // we need to also try modifying even indices in the current state
            if (b % 2 == 1) {
                // Try all possible add amounts for even indices (0-9)
                for (int addEven = 0; addEven < 10; addEven++) {
                    StringBuilder sb2 = new StringBuilder(withOdd);
                    for (int i = 0; i < n; i += 2) {
                        int digit = withOdd.charAt(i) - '0';
                        int newDigit = (digit + addEven * a) % 10;
                        sb2.setCharAt(i, (char) ('0' + newDigit));
                    }
                    String candidate = sb2.toString();
                    if (candidate.compareTo(best) < 0) {
                        best = candidate;
                    }
                }
            } else {
                // b is even, can only modify odd indices
                if (withOdd.compareTo(best) < 0) {
                    best = withOdd;
                }
            }
        }
        
        return best;
    }
    
    /**
     * Rotates the string right by b positions.
     */
    private String rotateRight(String s, int b) {
        int n = s.length();
        b = b % n;
        if (b == 0) return s;
        return s.substring(n - b) + s.substring(0, n - b);
    }
}
```

However, there's a more efficient approach that doesn't require BFS. Let me provide the optimized version:

```java
class Solution {
    public String findLexSmallestString(String s, int a, int b) {
        int n = s.length();
        String best = s;
        
        // Generate all unique rotations
        for (int i = 0; i < n; i++) {
            // Rotate right by b, i times
            String rotated = s;
            for (int j = 0; j < i; j++) {
                rotated = rotated.substring(n - b) + rotated.substring(0, n - b);
            }
            
            // Avoid infinite loop by checking if we've cycled back
            if (i > 0 && rotated.equals(s)) break;
            
            // Try all add combinations
            if (b % 2 == 1) {
                // Can modify both even and odd indices
                for (int addEven = 0; addEven < 10; addEven++) {
                    for (int addOdd = 0; addOdd < 10; addOdd++) {
                        String candidate = applyAdd(rotated, a, addEven, addOdd);
                        if (candidate.compareTo(best) < 0) {
                            best = candidate;
                        }
                    }
                }
            } else {
                // Can only modify odd indices
                for (int addOdd = 0; addOdd < 10; addOdd++) {
                    String candidate = applyAdd(rotated, a, 0, addOdd);
                    if (candidate.compareTo(best) < 0) {
                        best = candidate;
                    }
                }
            }
        }
        
        return best;
    }
    
    private String applyAdd(String s, int a, int addEven, int addOdd) {
        StringBuilder sb = new StringBuilder();
        for (int i = 0; i < s.length(); i++) {
            int digit = s.charAt(i) - '0';
            int addAmount = (i % 2 == 0) ? addEven : addOdd;
            int newDigit = (digit + addAmount * a) % 10;
            sb.append((char) ('0' + newDigit));
        }
        return sb.toString();
    }
}
```

But the cleanest and most efficient approach is:

```java
class Solution {
    public String findLexSmallestString(String s, int a, int b) {
        int n = s.length();
        String best = s;
        
        // Number of unique rotations
        int rotations = n / gcd(n, b);
        
        for (int rot = 0; rot < rotations; rot++) {
            // Get the rotated string
            String rotated = s.substring(n - rot * b % n) + s.substring(0, n - rot * b % n);
            // Actually, simpler to rotate step by step
        }
        
        // Instead, let's use the standard approach
        Set<String> seen = new HashSet<>();
        Queue<String> queue = new LinkedList<>();
        queue.offer(s);
        seen.add(s);
        
        while (!queue.isEmpty()) {
            String curr = queue.poll();
            if (curr.compareTo(best) < 0) best = curr;
            
            // Operation 1: Add a to odd indices
            StringBuilder sb1 = new StringBuilder(curr);
            for (int i = 1; i < n; i += 2) {
                sb1.setCharAt(i, (char) ('0' + (curr.charAt(i) - '0' + a) % 10));
            }
            String next1 = sb1.toString();
            if (!seen.contains(next1)) {
                seen.add(next1);
                queue.offer(next1);
            }
            
            // Operation 2: Rotate right by b
            String next2 = curr.substring(n - b) + curr.substring(0, n - b);
            if (!seen.contains(next2)) {
                seen.add(next2);
                queue.offer(next2);
            }
        }
        
        return best;
    }
    
    private int gcd(int a, int b) {
        return b == 0 ? a : gcd(b, a % b);
    }
}
```

Actually, the BFS approach is the most straightforward and guaranteed to work:

```java
class Solution {
    public String findLexSmallestString(String s, int a, int b) {
        Queue<String> queue = new LinkedList<>();
        Set<String> visited = new HashSet<>();
        queue.offer(s);
        visited.add(s);
        String best = s;
        
        while (!queue.isEmpty()) {
            String curr = queue.poll();
            if (curr.compareTo(best) < 0) {
                best = curr;
            }
            
            // Add operation: add a to all odd indices
            char[] chars1 = curr.toCharArray();
            for (int i = 1; i < chars1.length; i += 2) {
                chars1[i] = (char) ('0' + (chars1[i] - '0' + a) % 10);
            }
            String next1 = new String(chars1);
            if (!visited.contains(next1)) {
                visited.add(next1);
                queue.offer(next1);
            }
            
            // Rotate operation: rotate right by b
            String next2 = curr.substring(curr.length() - b) + curr.substring(0, curr.length() - b);
            if (!visited.contains(next2)) {
                visited.add(next2);
                queue.offer(next2);
            }
        }
        
        return best;
    }
}
```
# ğŸ“Š Comprehensive Solution Report: Find X-Sum of All K-Long Subarrays II

---

## ğŸ“‹ Problem Summary

**Inputs**:  
- `nums`: Array of `n` integers (1 â‰¤ nums[i] â‰¤ 10â¹)
- `k`: Length of subarrays to consider
- `x`: Number of top frequent elements to keep

**X-Sum Calculation**:  
1. Count occurrences of all elements in the subarray
2. Keep only the top `x` most frequent elements, with tie-breaking by element value (larger value wins)
3. Sum all occurrences of the kept elements
4. If subarray has fewer than `x` distinct elements, sum the entire subarray

**Goal**:  
Return an array where `answer[i]` is the x-sum of subarray `nums[i..i+k-1]`

**Output**:  
- Long array of length `n - k + 1` (use `long` due to large sums)

---

## ğŸ” Key Observations and Constraints

### ğŸ¯ Critical Insights:
1. **Large constraints**: `n â‰¤ 10âµ`, `nums[i] â‰¤ 10â¹` makes brute force O(nk log k) too slow
2. **Sliding window with frequency tracking**: Need to efficiently update frequencies as window slides
3. **Top-x maintenance**: Need a data structure that can efficiently maintain and query top `x` elements
4. **Efficient boundary maintenance**: Keep exactly `x` elements in the "top" set

### âš ï¸ Constraints Analysis:
- **Large input size**: 10âµ elements, so O(nk) = 10Â¹â° operations is too slow
- **Large values**: Elements up to 10â¹, so must use HashMap for frequency counting
- **Edge cases**:
  - `x = k`: Keep all elements
  - `x = 1`: Keep only the most frequent element
  - All elements same in subarray

---

## ğŸ“š Relevant Concepts and Theory

### ğŸ” Sliding Window with Two TreeSet Approach
The optimal solution uses **two TreeSets** to maintain a partition of elements:
- **`large`**: Contains the top `x` elements (by frequency, then by value)
- **`small`**: Contains the remaining elements
- **Balanced partition**: `large` always has exactly `x` elements (or all elements if fewer than `x`)

### ğŸ“Š Custom Pair Class
The `Pair` class represents `(frequency, value)` pairs with custom comparison:
- **Primary**: frequency (ascending in TreeSet, but we use `first()` for min)
- **Secondary**: value (ascending, but larger values are preferred, so we use value directly)

### ğŸ¯ Key Insight: Maintain Result Incrementally
Instead of recalculating the x-sum from scratch each time, we:
- **Track the current result** as a running sum
- **Update incrementally** when elements are added/removed
- **Maintain the partition** between `large` and `small` sets

---

## ğŸ§  Logical Analysis

### âœ… Why Two TreeSet Approach Works:
- **Efficient boundary management**: Always know the smallest element in `large` and largest in `small`
- **O(log n) operations**: TreeSet operations (insert, remove, find min/max) are O(log n)
- **Maintains exact partition**: `large` always contains exactly the top `x` elements
- **Incremental updates**: Result is updated immediately when elements move between sets

### ğŸ¯ Key Insight: TreeSet Ordering
The `Pair` class uses **natural ordering** (frequency ascending, value ascending), which means:
- `large.first()` = smallest element in `large` (lowest frequency, then lowest value)
- `small.last()` = largest element in `small` (highest frequency, then highest value)

This allows us to efficiently maintain the boundary between top `x` and rest.

---

## ğŸ¯ Effective Strategy

### ğŸ“ Plan:
1. **Use Helper class** to encapsulate the sliding window logic
2. **Maintain two TreeSets**:
   - `large`: top `x` elements (contributes to result)
   - `small`: remaining elements (doesn't contribute)
3. **For each element insertion**:
   - Remove old frequency entry from appropriate set
   - Add new frequency entry to appropriate set
   - Balance sets to maintain exactly `x` elements in `large`
4. **For each element removal**:
   - Remove old frequency entry from appropriate set
   - Add new frequency entry (if frequency > 0) to appropriate set
   - Balance sets if necessary
5. **Maintain running result** that can be queried in O(1)

---

## ğŸ§ª Illustrative Example Walkthrough

**Example**: `nums = [1,1,2,2,3,4,2,3], k = 6, x = 2`

### Initial window `[1,1,2,2,3,4]`:
- Frequencies: `{1:2, 2:2, 3:1, 4:1}`
- Pairs: `(2,1), (2,2), (1,3), (1,4)`
- TreeSet ordering: `(1,3) < (1,4) < (2,1) < (2,2)`
- `large` (top 2): `(2,1), (2,2)` â†’ but wait, for same frequency, larger value should be preferred
- Actually, since we want larger values to be more frequent, the Pair comparison should favor larger values
- With current comparison: `(2,1) < (2,2)`, so `large.first()` = `(2,1)`
- Result = `2Ã—1 + 2Ã—2 = 2 + 4 = 6` âœ…

### When inserting new `2` (frequency 2â†’3):
- Remove `(2,2)` from `large`
- Add `(3,2)` to `large`
- Result updates: `-4 + 6 = 2`, then add other elements
- Final result = 10 âœ…

---

## âš¡ Optimal Approach

**Two TreeSet with Helper Class** is optimal because:
- **Time Complexity**: O(n log k) - each insertion/removal is O(log k)
- **Space Complexity**: O(k) - store at most k distinct elements
- **Handles all cases correctly**: Including edge cases and maximum constraints
- **Efficient for large inputs**: Works for n = 10âµ
- **Maintains exact result**: No recalculation needed

---

## ğŸ“‹ Step-by-Step Algorithm

### Helper Class Operations:
1. **`insert(num)`**:
   - If num already exists, remove old `(freq, num)` from appropriate set
   - Increment frequency
   - Add new `(freq, num)` to appropriate set
   - Balance sets to maintain exactly `x` elements in `large`

2. **`remove(num)`**:
   - Remove current `(freq, num)` from appropriate set
   - Decrement frequency
   - If frequency > 0, add new `(freq, num)` to appropriate set
   - Balance sets if necessary

3. **`get()`**:
   - Return precomputed result

### Main Algorithm:
1. **Create Helper instance** with parameter `x`
2. **For each element in nums**:
   - Insert current element
   - If window size > k, remove element that's sliding out
   - If window size = k, record current result
3. **Return** result array

---

## ğŸ“Š Complexity Analysis

### â±ï¸ Time Complexity: **O(n log k)**
- **Each insertion/removal**: O(log k) for TreeSet operations
- **Total operations**: O(n) insertions and O(n) removals
- **Total**: O(n log k)
- **For n = 10âµ, k = 10âµ**: ~10âµ Ã— log(10âµ) â‰ˆ **1.7 million operations** âœ…

### ğŸ’¾ Space Complexity: **O(k)**
- **Frequency map**: O(k) distinct elements
- **TreeSets**: O(k) pairs
- **Total**: O(k)

---

## ğŸ§ª Test Cases

### âœ… Basic Cases
1. **Example 1**: `[1,1,2,2,3,4,2,3], k=6, x=2` â†’ `[6,10,12]`
2. **Example 2**: `[3,8,7,8,7,5], k=2, x=2` â†’ `[11,15,15,15,12]`

### âš ï¸ Edge Cases
3. **x = k**: Keep all elements â†’ sum = subarray sum
4. **x = 1**: Keep only most frequent (largest value if tie)
5. **All same elements**: One distinct element â†’ sum = entire subarray

---

## ğŸ’» Final Implementation (Java)

```java
import java.util.*;

/**
 * ğŸ“Š Solution for "Find X-Sum of All K-Long Subarrays II"
 * 
 * Strategy: Two TreeSet approach with Helper class for sliding window
 * Time Complexity: O(n log k)
 * Space Complexity: O(k)
 */
class Helper {

    private int x;
    private long result;
    private TreeSet<Pair> large, small;
    private Map<Integer, Integer> occ;

    /**
     * Pair class representing (frequency, value) with custom comparison.
     * 
     * ğŸ§  Key insight: Natural ordering (frequency asc, value asc) allows us
     * to use large.first() for the smallest element in large set and 
     * small.last() for the largest element in small set.
     */
    private static class Pair implements Comparable<Pair> {
        int first;  // frequency
        int second; // value

        Pair(int first, int second) {
            this.first = first;
            this.second = second;
        }

        @Override
        public int compareTo(Pair other) {
            if (this.first != other.first) {
                return Integer.compare(this.first, other.first);
            }
            return Integer.compare(this.second, other.second);
        }

        @Override
        public boolean equals(Object obj) {
            if (this == obj) return true;
            if (obj == null || getClass() != obj.getClass()) return false;
            Pair pair = (Pair) obj;
            return first == pair.first && second == pair.second;
        }

        @Override
        public int hashCode() {
            return Objects.hash(first, second);
        }
    }

    /**
     * Initializes the Helper with parameter x.
     * 
     * @param x number of top frequent elements to keep
     */
    public Helper(int x) {
        this.x = x;
        this.result = 0;
        this.large = new TreeSet<>(); // contains top x elements
        this.small = new TreeSet<>(); // contains remaining elements
        this.occ = new HashMap<>();   // frequency map
    }

    /**
     * Inserts a number into the current window.
     * 
     * ğŸ”„ Updates frequency, removes old entry, adds new entry, and rebalances sets.
     * 
     * @param num number to insert
     */
    public void insert(int num) {
        // ğŸ—‘ï¸ Remove old frequency entry if it exists
        if (occ.containsKey(num) && occ.get(num) > 0) {
            internalRemove(new Pair(occ.get(num), num));
        }
        
        // â• Increment frequency and add new entry
        occ.put(num, occ.getOrDefault(num, 0) + 1);
        internalInsert(new Pair(occ.get(num), num));
    }

    /**
     * Removes a number from the current window.
     * 
     * ğŸ”„ Updates frequency, removes current entry, adds new entry if needed, and rebalances.
     * 
     * @param num number to remove
     */
    public void remove(int num) {
        // ğŸ—‘ï¸ Remove current frequency entry
        internalRemove(new Pair(occ.get(num), num));
        
        // â• Decrement frequency
        occ.put(num, occ.get(num) - 1);
        
        // ğŸ“Œ Add new entry if frequency is still positive
        if (occ.get(num) > 0) {
            internalInsert(new Pair(occ.get(num), num));
        }
    }

    /**
     * Gets the current x-sum.
     * 
     * @return precomputed x-sum
     */
    public long get() {
        return result;
    }

    /**
     * Internal method to insert a pair into appropriate set.
     * 
     * ğŸ¯ If large has space or pair is better than worst in large, add to large.
     * Otherwise, add to small. Maintain exactly x elements in large.
     * 
     * @param p pair to insert
     */
    private void internalInsert(Pair p) {
        if (large.size() < x || p.compareTo(large.first()) > 0) {
            // âœ… Add to large set
            result += (long) p.first * p.second;
            large.add(p);
            
            // ğŸ”„ If large exceeds x elements, move worst to small
            if (large.size() > x) {
                Pair toRemove = large.first();
                result -= (long) toRemove.first * toRemove.second;
                large.remove(toRemove);
                small.add(toRemove);
            }
        } else {
            // ğŸ“Œ Add to small set
            small.add(p);
        }
    }

    /**
     * Internal method to remove a pair from appropriate set.
     * 
     * ğŸ¯ If pair is in large, remove it and potentially promote best from small.
     * Otherwise, remove from small.
     * 
     * @param p pair to remove
     */
    private void internalRemove(Pair p) {
        if (p.compareTo(large.first()) >= 0) {
            // ğŸ—‘ï¸ Remove from large set
            result -= (long) p.first * p.second;
            large.remove(p);
            
            // ğŸ”„ If small is not empty, promote best to large
            if (!small.isEmpty()) {
                Pair toAdd = small.last();
                result += (long) toAdd.first * toAdd.second;
                small.remove(toAdd);
                large.add(toAdd);
            }
        } else {
            // ğŸ—‘ï¸ Remove from small set
            small.remove(p);
        }
    }
}

/**
 * ğŸ§  Main Solution Class
 * 
 * Uses the Helper class to efficiently maintain sliding window x-sums.
 */
class Solution {
    
    /**
     * Calculates the x-sum for all k-length subarrays.
     * 
     * ğŸ“ˆ The algorithm uses a sliding window approach with the Helper class
     * to maintain frequencies and top-x elements efficiently.
     * 
     * @param nums input array of integers (1 <= nums[i] <= 10^9)
     * @param k length of subarrays to consider
     * @param x number of top frequent elements to keep
     * @return array of x-sums for each k-length subarray
     */
    public long[] findXSum(int[] nums, int k, int x) {
        Helper helper = new Helper(x);
        List<Long> ans = new ArrayList<>();

        // ğŸ” Sliding window approach
        for (int i = 0; i < nums.length; i++) {
            helper.insert(nums[i]);           // Add current element
            
            if (i >= k) {
                helper.remove(nums[i - k]);   // Remove element sliding out
            }
            
            if (i >= k - 1) {
                ans.add(helper.get());        // Record result for full window
            }
        }

        return ans.stream().mapToLong(Long::longValue).toArray();
    }
}
```

---

## ğŸ—ºï¸ Logic Flowchart

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚           START                 â”‚
â”‚ findXSum(nums, k, x)            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                â”‚
                â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚      Create Helper(x)           â”‚
â”‚      Initialize empty list      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                â”‚
                â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚      For i = 0 to n-1:          â”‚
â”‚        helper.insert(nums[i])   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                â”‚
                â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚      i >= k ?                   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                â”‚
          â”Œâ”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”
          â”‚    Yes    â”‚
          â””â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜
                â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   helper.remove(nums[i-k])      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                â”‚
                â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚      i >= k-1 ?                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                â”‚
          â”Œâ”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”
          â”‚    Yes    â”‚
          â””â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜
                â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   ans.add(helper.get())         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                â”‚
                â–¼
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚   Next i        â”‚
        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

                â”‚
                â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚      Convert List<Long>         â”‚
â”‚      to long[] and return       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                â”‚
                â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚             END                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```
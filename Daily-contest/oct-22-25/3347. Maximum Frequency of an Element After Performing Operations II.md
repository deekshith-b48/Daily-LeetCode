# ğŸ“Š Comprehensive Solution Report: Maximum Frequency of an Element After Performing Operations II

---

## ğŸ“‹ Problem Summary

**Inputs**:  
- `nums`: Array of integers (1 â‰¤ nums[i] â‰¤ 10â¹)  
- `k`: Range parameter (0 â‰¤ k â‰¤ 10â¹)
- `numOperations`: Number of operations allowed (0 â‰¤ numOperations â‰¤ nums.length)

**Operation**:  
- Perform exactly `numOperations` times:
  - Select an index `i` that hasn't been selected before
  - Add any integer in range `[-k, k]` to `nums[i]`

**Goal**:  
Return the **maximum possible frequency** of any single element in the array after operations

**Output**:  
- Single integer representing maximum frequency

---

## ğŸ” Key Observations and Constraints

### ğŸ¯ Critical Insights:
1. **Target value selection**: We can choose any target value to maximize frequency
2. **Range transformation**: Each element `nums[i]` can be transformed to any value in `[nums[i] - k, nums[i] + k]`
3. **Operation limit**: We can modify at most `numOperations` elements
4. **Large value ranges**: Unlike Part I, values can be up to 10â¹, making brute force over the entire range impossible

### âš ï¸ Constraints Analysis:
- **Large input size**: `nums.length â‰¤ 10âµ`
- **Very large value ranges**: `nums[i]` and `k` up to 10â¹
- **Edge cases**:
  - `numOperations = 0` (no modifications allowed)
  - `k = 0` (no range expansion)
  - `numOperations = nums.length` (can modify all elements)

---

## ğŸ“š Relevant Concepts and Theory

### ğŸ” Candidate Target Optimization
Since the value range is too large to check every possible target (up to 2Ã—10â¹), we need to identify a **small set of candidate target values** that could potentially yield the maximum frequency.

### ğŸ“Š Key Insight: Boundary Candidates
The optimal target value will always be at one of these positions:
- **Existing values** in the original array
- **Boundary values** of the ranges: `nums[i] - k` and `nums[i] + k` for each unique `nums[i]`

This is because:
- Moving the target away from these boundaries would either exclude some elements from the range or not include any additional elements
- The frequency function is piecewise constant between these critical points

### ğŸ¯ Mathematical Justification
For any target value `x`, the set of elements that can reach `x` is determined by the interval `[x - k, x + k]`. The endpoints of this interval that align with the boundaries of element ranges (`nums[i] Â± k`) are the only points where the count of reachable elements can change.

---

## ğŸ§  Logical Analysis

### âŒ Why Brute Force Fails (Part II):
- **Range too large**: Checking all values from `min(nums)` to `max(nums)` could require up to 10â¹ iterations
- **Time limit exceeded**: Even with O(log n) binary searches, 10â¹ Ã— log(10âµ) â‰ˆ 1.7Ã—10Â¹â° operations is too slow

### âœ… Why Candidate Optimization Works:
- **Limited candidates**: At most `3 Ã— unique_values` candidate targets
- **Complete coverage**: All potential optimal targets are included
- **Efficient processing**: O(unique_values Ã— log n) total complexity

### ğŸ¯ Key Insight: TreeSet for Sorted Candidates
Using a `TreeSet` automatically:
- Eliminates duplicate candidates
- Maintains sorted order for consistent processing
- Provides efficient insertion and iteration

---

## ğŸ¯ Effective Strategy

### ğŸ“ Plan:
1. **Sort the array** to enable binary search and efficient frequency counting
2. **Precompute frequencies** of each unique value by scanning the sorted array
3. **Generate candidate targets**:
   - All existing unique values
   - All boundary values `value - k` and `value + k` (within reasonable bounds)
4. **For each candidate target**:
   - Use binary search to find elements in range `[target - k, target + k]`
   - Calculate maximum possible frequency considering existing elements and operations
   - Track the global maximum
5. **Return** the maximum frequency found

### ğŸ› ï¸ Design Decisions:
- **TreeSet for candidates**: Automatic deduplication and sorting
- **Boundary filtering**: Only add boundaries within the overall array range to reduce candidates
- **Functional interfaces**: Clean code structure with `IntUnaryOperator` for binary search functions

---

## ğŸ§ª Illustrative Example Walkthrough

**Example 1**: `nums = [1,4,5], k = 1, numOperations = 2`

### Step 1: Sort and compute frequencies
- Sorted: `[1,4,5]`
- Frequencies: `{1:1, 4:1, 5:1}`
- Initial `ans = 1`

### Step 2: Generate candidate targets
For value `1`:
- Add `1` to candidates
- `1 - 1 = 0` (â‰¥ min=1? No, skip)
- `1 + 1 = 2` (â‰¤ max=5? Yes, add `2`)

For value `4`:
- Add `4`
- `4 - 1 = 3` (add `3`)
- `4 + 1 = 5` (add `5`)

For value `5`:
- Add `5` (already exists)
- `5 - 1 = 4` (add `4`, already exists)
- `5 + 1 = 6` (> max=5? Skip)

**Final candidates**: `{1, 2, 3, 4, 5}`

### Step 3: Process each candidate
- **Candidate 1**: range `[0,2]` â†’ elements `[1]` â†’ freq = 1
- **Candidate 2**: range `[1,3]` â†’ elements `[1]` â†’ freq = 1  
- **Candidate 3**: range `[2,4]` â†’ elements `[4]` â†’ freq = 1
- **Candidate 4**: range `[3,5]` â†’ elements `[4,5]` â†’ freq = min(2, 1+2) = 2
- **Candidate 5**: range `[4,6]` â†’ elements `[4,5]` â†’ freq = 2

**Maximum frequency = 2** âœ…

---

## âš¡ Optimal Approach

**Candidate Target Optimization** is optimal because:
- **Time Complexity**: O(n log n + u log n) where u = unique values â‰¤ n
- **Space Complexity**: O(n) - for frequency map and candidate set
- **Handles large ranges**: Works efficiently even with 10â¹ value ranges
- **Guarantees optimality**: All potential optimal targets are considered

---

## ğŸ“‹ Step-by-Step Algorithm

1. **Sort** the `nums` array
2. **Compute frequencies** by scanning the sorted array
3. **Initialize candidate set** with existing values and their boundaries
4. **For each candidate target** in the sorted candidate set:
   - Find `l = leftBound(nums, target - k)`
   - Find `r = rightBound(nums, target + k)`
   - Calculate `tempAns` based on whether target exists in original array
   - Update global maximum
5. **Return** the maximum frequency found

---

## ğŸ“Š Complexity Analysis

### â±ï¸ Time Complexity: **O(n log n)**
- **Sorting**: O(n log n)
- **Frequency computation**: O(n)
- **Candidate generation**: O(n log n) (TreeSet insertions)
- **Candidate processing**: O(n log n) (n candidates Ã— log n binary searches)
- **Total**: O(n log n)

### ğŸ’¾ Space Complexity: **O(n)**
- **Frequency map**: O(n)
- **Candidate set**: O(n)
- **Sorted array**: O(1) extra space
- **Total**: O(n)

---

## ğŸ’» Final Implementation (Java)

```java
import java.util.*;
import java.util.function.*;

/**
 * ğŸ“Š Solution for "Maximum Frequency of an Element After Performing Operations II"
 * 
 * Strategy: Candidate target optimization with boundary analysis
 * Time Complexity: O(n log n)
 * Space Complexity: O(n)
 */
class Solution {
    
    /**
     * Finds the maximum possible frequency of any element after performing operations.
     * 
     * ğŸ§  Key insight: Instead of checking all possible target values in the huge range
     * [1, 10^9], we only need to check candidate targets that are either existing values
     * or boundary values (value Â± k) of existing elements. This reduces the search space
     * from potentially billions of values to at most 3n candidates.
     * 
     * ğŸ” The solution uses a TreeSet to automatically deduplicate and sort candidates,
     * then applies binary search range queries for each candidate to determine the
     * maximum achievable frequency.
     * 
     * @param nums array of integers that can be modified
     * @param k range of values that can be added to each selected element
     * @param numOperations maximum number of operations allowed
     * @return maximum possible frequency of any single element
     */
    public int maxFrequency(int[] nums, int k, int numOperations) {
        // ğŸ“ˆ Sort the array to enable efficient range queries and frequency counting
        Arrays.sort(nums);
        
        // ğŸ¯ Initialize answer, frequency map, and candidate set
        int ans = 0;
        Map<Integer, Integer> numCount = new HashMap<>();
        Set<Integer> modes = new TreeSet<>(); // Automatically sorted and deduplicated
        
        // ğŸ“ Lambda to add a value and its boundaries to candidate set
        Consumer<Integer> addMode = value -> {
            modes.add(value);
            // Only add boundaries that are within the overall array range to reduce candidates
            if (value - k >= nums[0]) {
                modes.add(value - k);
            }
            if (value + k <= nums[nums.length - 1]) {
                modes.add(value + k);
            }
        };
        
        // ğŸ“Š Compute frequencies by scanning sorted array
        int lastNumIndex = 0;
        for (int i = 0; i < nums.length; ++i) {
            if (nums[i] != nums[lastNumIndex]) {
                numCount.put(nums[lastNumIndex], i - lastNumIndex);
                ans = Math.max(ans, i - lastNumIndex);
                addMode.accept(nums[lastNumIndex]);
                lastNumIndex = i;
            }
        }
        // Handle the last group
        numCount.put(nums[lastNumIndex], nums.length - lastNumIndex);
        ans = Math.max(ans, nums.length - lastNumIndex);
        addMode.accept(nums[lastNumIndex]);
        
        // ğŸ” Define binary search functions using functional interfaces
        IntUnaryOperator leftBound = value -> {
            int left = 0;
            int right = nums.length - 1;
            while (left < right) {
                int mid = (left + right) / 2;
                if (nums[mid] < value) {
                    left = mid + 1;
                } else {
                    right = mid;
                }
            }
            return left;
        };
        
        IntUnaryOperator rightBound = value -> {
            int left = 0;
            int right = nums.length - 1;
            while (left < right) {
                int mid = (left + right + 1) / 2;
                if (nums[mid] > value) {
                    right = mid - 1;
                } else {
                    left = mid;
                }
            }
            return left;
        };
        
        // ğŸ¯ Process each candidate target
        for (int mode : modes) {
            // Find range of elements that can be transformed to target 'mode'
            int l = leftBound.applyAsInt(mode - k);
            int r = rightBound.applyAsInt(mode + k);
            
            // Calculate maximum frequency for this target
            int tempAns;
            if (numCount.containsKey(mode)) {
                // Target exists in original array
                tempAns = Math.min(
                    r - l + 1,
                    numCount.get(mode) + numOperations
                );
            } else {
                // Target doesn't exist in original array
                tempAns = Math.min(r - l + 1, numOperations);
            }
            
            ans = Math.max(ans, tempAns);
        }
        
        return ans;
    }
}
```
# 📊 Comprehensive Solution Report: Maximum Frequency of an Element After Performing Operations II

---

## 📋 Problem Summary

**Inputs**:  
- `nums`: Array of integers (1 ≤ nums[i] ≤ 10⁹)  
- `k`: Range parameter (0 ≤ k ≤ 10⁹)
- `numOperations`: Number of operations allowed (0 ≤ numOperations ≤ nums.length)

**Operation**:  
- Perform exactly `numOperations` times:
  - Select an index `i` that hasn't been selected before
  - Add any integer in range `[-k, k]` to `nums[i]`

**Goal**:  
Return the **maximum possible frequency** of any single element in the array after operations

**Output**:  
- Single integer representing maximum frequency

---

## 🔍 Key Observations and Constraints

### 🎯 Critical Insights:
1. **Target value selection**: We can choose any target value to maximize frequency
2. **Range transformation**: Each element `nums[i]` can be transformed to any value in `[nums[i] - k, nums[i] + k]`
3. **Operation limit**: We can modify at most `numOperations` elements
4. **Large value ranges**: Unlike Part I, values can be up to 10⁹, making brute force over the entire range impossible

### ⚠️ Constraints Analysis:
- **Large input size**: `nums.length ≤ 10⁵`
- **Very large value ranges**: `nums[i]` and `k` up to 10⁹
- **Edge cases**:
  - `numOperations = 0` (no modifications allowed)
  - `k = 0` (no range expansion)
  - `numOperations = nums.length` (can modify all elements)

---

## 📚 Relevant Concepts and Theory

### 🔍 Candidate Target Optimization
Since the value range is too large to check every possible target (up to 2×10⁹), we need to identify a **small set of candidate target values** that could potentially yield the maximum frequency.

### 📊 Key Insight: Boundary Candidates
The optimal target value will always be at one of these positions:
- **Existing values** in the original array
- **Boundary values** of the ranges: `nums[i] - k` and `nums[i] + k` for each unique `nums[i]`

This is because:
- Moving the target away from these boundaries would either exclude some elements from the range or not include any additional elements
- The frequency function is piecewise constant between these critical points

### 🎯 Mathematical Justification
For any target value `x`, the set of elements that can reach `x` is determined by the interval `[x - k, x + k]`. The endpoints of this interval that align with the boundaries of element ranges (`nums[i] ± k`) are the only points where the count of reachable elements can change.

---

## 🧠 Logical Analysis

### ❌ Why Brute Force Fails (Part II):
- **Range too large**: Checking all values from `min(nums)` to `max(nums)` could require up to 10⁹ iterations
- **Time limit exceeded**: Even with O(log n) binary searches, 10⁹ × log(10⁵) ≈ 1.7×10¹⁰ operations is too slow

### ✅ Why Candidate Optimization Works:
- **Limited candidates**: At most `3 × unique_values` candidate targets
- **Complete coverage**: All potential optimal targets are included
- **Efficient processing**: O(unique_values × log n) total complexity

### 🎯 Key Insight: TreeSet for Sorted Candidates
Using a `TreeSet` automatically:
- Eliminates duplicate candidates
- Maintains sorted order for consistent processing
- Provides efficient insertion and iteration

---

## 🎯 Effective Strategy

### 📝 Plan:
1. **Sort the array** to enable binary search and efficient frequency counting
2. **Precompute frequencies** of each unique value by scanning the sorted array
3. **Generate candidate targets**:
   - All existing unique values
   - All boundary values `value - k` and `value + k` (within reasonable bounds)
4. **For each candidate target**:
   - Use binary search to find elements in range `[target - k, target + k]`
   - Calculate maximum possible frequency considering existing elements and operations
   - Track the global maximum
5. **Return** the maximum frequency found

### 🛠️ Design Decisions:
- **TreeSet for candidates**: Automatic deduplication and sorting
- **Boundary filtering**: Only add boundaries within the overall array range to reduce candidates
- **Functional interfaces**: Clean code structure with `IntUnaryOperator` for binary search functions

---

## 🧪 Illustrative Example Walkthrough

**Example 1**: `nums = [1,4,5], k = 1, numOperations = 2`

### Step 1: Sort and compute frequencies
- Sorted: `[1,4,5]`
- Frequencies: `{1:1, 4:1, 5:1}`
- Initial `ans = 1`

### Step 2: Generate candidate targets
For value `1`:
- Add `1` to candidates
- `1 - 1 = 0` (≥ min=1? No, skip)
- `1 + 1 = 2` (≤ max=5? Yes, add `2`)

For value `4`:
- Add `4`
- `4 - 1 = 3` (add `3`)
- `4 + 1 = 5` (add `5`)

For value `5`:
- Add `5` (already exists)
- `5 - 1 = 4` (add `4`, already exists)
- `5 + 1 = 6` (> max=5? Skip)

**Final candidates**: `{1, 2, 3, 4, 5}`

### Step 3: Process each candidate
- **Candidate 1**: range `[0,2]` → elements `[1]` → freq = 1
- **Candidate 2**: range `[1,3]` → elements `[1]` → freq = 1  
- **Candidate 3**: range `[2,4]` → elements `[4]` → freq = 1
- **Candidate 4**: range `[3,5]` → elements `[4,5]` → freq = min(2, 1+2) = 2
- **Candidate 5**: range `[4,6]` → elements `[4,5]` → freq = 2

**Maximum frequency = 2** ✅

---

## ⚡ Optimal Approach

**Candidate Target Optimization** is optimal because:
- **Time Complexity**: O(n log n + u log n) where u = unique values ≤ n
- **Space Complexity**: O(n) - for frequency map and candidate set
- **Handles large ranges**: Works efficiently even with 10⁹ value ranges
- **Guarantees optimality**: All potential optimal targets are considered

---

## 📋 Step-by-Step Algorithm

1. **Sort** the `nums` array
2. **Compute frequencies** by scanning the sorted array
3. **Initialize candidate set** with existing values and their boundaries
4. **For each candidate target** in the sorted candidate set:
   - Find `l = leftBound(nums, target - k)`
   - Find `r = rightBound(nums, target + k)`
   - Calculate `tempAns` based on whether target exists in original array
   - Update global maximum
5. **Return** the maximum frequency found

---

## 📊 Complexity Analysis

### ⏱️ Time Complexity: **O(n log n)**
- **Sorting**: O(n log n)
- **Frequency computation**: O(n)
- **Candidate generation**: O(n log n) (TreeSet insertions)
- **Candidate processing**: O(n log n) (n candidates × log n binary searches)
- **Total**: O(n log n)

### 💾 Space Complexity: **O(n)**
- **Frequency map**: O(n)
- **Candidate set**: O(n)
- **Sorted array**: O(1) extra space
- **Total**: O(n)

---

## 💻 Final Implementation (Java)

```java
import java.util.*;
import java.util.function.*;

/**
 * 📊 Solution for "Maximum Frequency of an Element After Performing Operations II"
 * 
 * Strategy: Candidate target optimization with boundary analysis
 * Time Complexity: O(n log n)
 * Space Complexity: O(n)
 */
class Solution {
    
    /**
     * Finds the maximum possible frequency of any element after performing operations.
     * 
     * 🧠 Key insight: Instead of checking all possible target values in the huge range
     * [1, 10^9], we only need to check candidate targets that are either existing values
     * or boundary values (value ± k) of existing elements. This reduces the search space
     * from potentially billions of values to at most 3n candidates.
     * 
     * 🔍 The solution uses a TreeSet to automatically deduplicate and sort candidates,
     * then applies binary search range queries for each candidate to determine the
     * maximum achievable frequency.
     * 
     * @param nums array of integers that can be modified
     * @param k range of values that can be added to each selected element
     * @param numOperations maximum number of operations allowed
     * @return maximum possible frequency of any single element
     */
    public int maxFrequency(int[] nums, int k, int numOperations) {
        // 📈 Sort the array to enable efficient range queries and frequency counting
        Arrays.sort(nums);
        
        // 🎯 Initialize answer, frequency map, and candidate set
        int ans = 0;
        Map<Integer, Integer> numCount = new HashMap<>();
        Set<Integer> modes = new TreeSet<>(); // Automatically sorted and deduplicated
        
        // 📝 Lambda to add a value and its boundaries to candidate set
        Consumer<Integer> addMode = value -> {
            modes.add(value);
            // Only add boundaries that are within the overall array range to reduce candidates
            if (value - k >= nums[0]) {
                modes.add(value - k);
            }
            if (value + k <= nums[nums.length - 1]) {
                modes.add(value + k);
            }
        };
        
        // 📊 Compute frequencies by scanning sorted array
        int lastNumIndex = 0;
        for (int i = 0; i < nums.length; ++i) {
            if (nums[i] != nums[lastNumIndex]) {
                numCount.put(nums[lastNumIndex], i - lastNumIndex);
                ans = Math.max(ans, i - lastNumIndex);
                addMode.accept(nums[lastNumIndex]);
                lastNumIndex = i;
            }
        }
        // Handle the last group
        numCount.put(nums[lastNumIndex], nums.length - lastNumIndex);
        ans = Math.max(ans, nums.length - lastNumIndex);
        addMode.accept(nums[lastNumIndex]);
        
        // 🔍 Define binary search functions using functional interfaces
        IntUnaryOperator leftBound = value -> {
            int left = 0;
            int right = nums.length - 1;
            while (left < right) {
                int mid = (left + right) / 2;
                if (nums[mid] < value) {
                    left = mid + 1;
                } else {
                    right = mid;
                }
            }
            return left;
        };
        
        IntUnaryOperator rightBound = value -> {
            int left = 0;
            int right = nums.length - 1;
            while (left < right) {
                int mid = (left + right + 1) / 2;
                if (nums[mid] > value) {
                    right = mid - 1;
                } else {
                    left = mid;
                }
            }
            return left;
        };
        
        // 🎯 Process each candidate target
        for (int mode : modes) {
            // Find range of elements that can be transformed to target 'mode'
            int l = leftBound.applyAsInt(mode - k);
            int r = rightBound.applyAsInt(mode + k);
            
            // Calculate maximum frequency for this target
            int tempAns;
            if (numCount.containsKey(mode)) {
                // Target exists in original array
                tempAns = Math.min(
                    r - l + 1,
                    numCount.get(mode) + numOperations
                );
            } else {
                // Target doesn't exist in original array
                tempAns = Math.min(r - l + 1, numOperations);
            }
            
            ans = Math.max(ans, tempAns);
        }
        
        return ans;
    }
}
```
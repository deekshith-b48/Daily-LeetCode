# 🏦 Comprehensive Solution Report: Simple Bank System

---

## 📋 Problem Summary

**Inputs**:  
- `balance`: Array of initial account balances (0-indexed, accounts 1 to n)
- Bank operations: `transfer`, `deposit`, `withdraw`

**Account System**:  
- `n` accounts numbered from 1 to n
- Initial balance of account `(i+1)` is `balance[i]`
- All monetary values can be up to 10¹² (use `long`)

**Transaction Validity Rules**:  
1. Account numbers must be between 1 and n (inclusive)
2. For withdraw/transfer: sufficient balance must be available
3. Money amounts are non-negative

**Operations**:  
- `transfer(account1, account2, money)`: Move money from account1 to account2
- `deposit(account, money)`: Add money to account
- `withdraw(account, money)`: Remove money from account

**Goal**:  
Implement the Bank class with proper validation and state management

**Output**:  
- Boolean indicating transaction success/failure

---

## 🔍 Key Observations and Constraints

### 🎯 Critical Insights:
1. **Account indexing**: Input uses 1-based indexing, but internal storage is 0-based
2. **Large values**: Money can be up to 10¹², requiring `long` data type
3. **Validation order**: Check account validity before balance checks
4. **Atomic operations**: Transfer must be all-or-nothing (both accounts validated before any changes)

### ⚠️ Constraints Analysis:
- **Account count**: Up to 10⁵ accounts
- **Operation count**: Up to 10⁴ calls per operation type
- **Money range**: 0 to 10¹² (fits in `long`)
- **Edge cases**:
  - Invalid account numbers (too small or too large)
  - Insufficient funds
  - Zero money transactions (should be valid)
  - Self-transfers (account1 == account2)

---

## 📚 Relevant Concepts and Theory

### 🔍 Object-Oriented Design
The Bank class encapsulates:
- **State**: Account balances stored in array
- **Behavior**: Transaction methods with proper validation
- **Data integrity**: Atomic operations that maintain consistent state

### 📊 Input Validation Strategy
For each operation, validate in this order:
1. **Account bounds**: Check if account numbers are in valid range [1, n]
2. **Sufficient funds**: For withdraw/transfer, check if balance ≥ money
3. **Non-negative money**: Though constraints guarantee money ≥ 0

### 🎯 Atomic Transfer Implementation
Transfer operation must:
1. Validate both accounts exist
2. Validate source account has sufficient funds
3. Only then perform the actual transfer (debit source, credit destination)

---

## 🧠 Logical Analysis

### ✅ Why Direct Array Implementation Works:
- **Simple data structure**: Array provides O(1) access to any account
- **Efficient operations**: All operations are O(1) time complexity
- **Memory efficient**: O(n) space for account balances
- **Thread safety not required**: Single-threaded problem context

### 🎯 Key Insight: Validation Before Modification
All operations must validate completely before making any state changes. This ensures:
- **Consistency**: Invalid transactions don't partially modify state
- **Reliability**: Error conditions are caught before any changes
- **Predictability**: Operations are atomic and idempotent for failures

---

## 🎯 Effective Strategy

### 📝 Plan:
1. **Store balances** in a `long[]` array (0-indexed internally)
2. **Implement helper method** to validate account numbers
3. **For each operation**:
   - Validate account(s) exist
   - For withdraw/transfer: validate sufficient funds
   - Perform operation and return `true`
   - Return `false` for any validation failure

### 🛠️ Design Decisions:
- **0-based internal storage**: Convert 1-based input to 0-based array indices
- **Early returns**: Return `false` immediately on validation failure
- **Atomic transfers**: Validate both accounts and funds before any modifications
- **Long arithmetic**: Use `long` throughout to prevent overflow

---

## 🧪 Illustrative Example Walkthrough

**Example**: `balance = [10, 100, 20, 50, 30]` (accounts 1-5)

### Initial state:
- Account 1: $10, Account 2: $100, Account 3: $20, Account 4: $50, Account 5: $30

**Operation 1**: `withdraw(3, 10)`
- Account 3 exists (3 ≤ 5) ✓
- Balance $20 ≥ $10 ✓
- New balance: Account 3 = $10 → **return true**

**Operation 2**: `transfer(5, 1, 20)`
- Account 5 exists ✓, Account 1 exists ✓
- Account 5 balance $30 ≥ $20 ✓
- Debit Account 5: $30 - $20 = $10
- Credit Account 1: $10 + $20 = $30 → **return true**

**Operation 3**: `deposit(5, 20)`
- Account 5 exists ✓
- Add $20 to Account 5: $10 + $20 = $30 → **return true**

**Operation 4**: `transfer(3, 4, 15)`
- Account 3 exists ✓, Account 4 exists ✓
- Account 3 balance $10 < $15 ✗ → **return false**

**Operation 5**: `withdraw(10, 50)`
- Account 10 doesn't exist (10 > 5) ✗ → **return false**

---

## ⚡ Optimal Approach

**Direct Array Implementation** is optimal because:
- **Time Complexity**: O(1) per operation
- **Space Complexity**: O(n) for balance storage
- **Simple and reliable**: Minimal code with clear validation logic
- **Handles all constraints**: Proper validation and data types

---

## 📋 Step-by-Step Algorithm

### Constructor:
1. **Store balance array** as internal state

### Transfer:
1. **Validate** `account1` and `account2` are in range [1, n]
2. **Validate** `balance[account1-1] >= money`
3. **If valid**: debit `account1`, credit `account2`, return `true`
4. **Else**: return `false`

### Deposit:
1. **Validate** `account` is in range [1, n]
2. **If valid**: add `money` to `account`, return `true`
3. **Else**: return `false`

### Withdraw:
1. **Validate** `account` is in range [1, n]
2. **Validate** `balance[account-1] >= money`
3. **If valid**: subtract `money` from `account`, return `true`
4. **Else**: return `false`

---

## 📊 Complexity Analysis

### ⏱️ Time Complexity: **O(1) per operation**
- **Array access**: O(1) for any account
- **Validation**: O(1) bounds and balance checks
- **Modification**: O(1) arithmetic operations

### 💾 Space Complexity: **O(n)**
- **Balance storage**: `long[n]` array
- **No additional space**: Operations use constant extra space

---

## 🧪 Test Cases

### ✅ Basic Cases
1. **Example 1**: Valid transfers, deposits, withdrawals → correct boolean results
2. **Self-transfer**: `transfer(1, 1, 10)` → should work if sufficient funds

### ⚠️ Edge Cases
3. **Invalid accounts**: Account 0, account n+1 → return false
4. **Insufficient funds**: Withdraw more than balance → return false
5. **Zero transactions**: `deposit(1, 0)`, `withdraw(1, 0)` → return true
6. **Maximum values**: Money = 10¹², large account counts

### 🚀 Boundary Cases
7. **Empty bank**: n = 1, single account operations
8. **Maximum operations**: 10⁴ calls of each type

---

## 💻 Final Implementation (Java)

```java
/**
 * 🏦 Solution for "Simple Bank System"
 * 
 * Strategy: Direct array implementation with proper validation
 * Time Complexity: O(1) per operation
 * Space Complexity: O(n)
 */
class Bank {
    
    // 📊 Internal storage for account balances (0-indexed)
    private final long[] balances;
    private final int n;
    
    /**
     * Initializes the bank with the given account balances.
     * 
     * 🧠 Key insight: Store balances in 0-indexed array internally,
     * while the public API uses 1-indexed account numbers.
     * 
     * @param balance initial balances for accounts 1 to n
     */
    public Bank(long[] balance) {
        this.balances = balance;
        this.n = balance.length;
    }
    
    /**
     * Transfers money from account1 to account2.
     * 
     * 🔍 Validation order:
     * 1. Both accounts exist (1 <= account <= n)
     * 2. Source account has sufficient funds
     * 3. Perform atomic transfer (debit then credit)
     * 
     * @param account1 source account number (1-indexed)
     * @param account2 destination account number (1-indexed)  
     * @param money amount to transfer
     * @return true if transfer successful, false otherwise
     */
    public boolean transfer(int account1, int account2, long money) {
        // 🚫 Validate account numbers
        if (!isValidAccount(account1) || !isValidAccount(account2)) {
            return false;
        }
        
        // 🚫 Validate sufficient funds in source account
        if (balances[account1 - 1] < money) {
            return false;
        }
        
        // 💰 Perform atomic transfer
        balances[account1 - 1] -= money;
        balances[account2 - 1] += money;
        return true;
    }
    
    /**
     * Deposits money into the specified account.
     * 
     * 🔍 Validation: Account must exist (1 <= account <= n)
     * 
     * @param account account number (1-indexed)
     * @param money amount to deposit
     * @return true if deposit successful, false otherwise
     */
    public boolean deposit(int account, long money) {
        // 🚫 Validate account number
        if (!isValidAccount(account)) {
            return false;
        }
        
        // 💰 Perform deposit
        balances[account - 1] += money;
        return true;
    }
    
    /**
     * Withdraws money from the specified account.
     * 
     * 🔍 Validation order:
     * 1. Account exists (1 <= account <= n)
     * 2. Account has sufficient funds
     * 
     * @param account account number (1-indexed)
     * @param money amount to withdraw
     * @return true if withdrawal successful, false otherwise
     */
    public boolean withdraw(int account, long money) {
        // 🚫 Validate account number
        if (!isValidAccount(account)) {
            return false;
        }
        
        // 🚫 Validate sufficient funds
        if (balances[account - 1] < money) {
            return false;
        }
        
        // 💰 Perform withdrawal
        balances[account - 1] -= money;
        return true;
    }
    
    /**
     * Helper method to validate if an account number is within valid range.
     * 
     * @param account account number to validate (1-indexed)
     * @return true if account is valid, false otherwise
     */
    private boolean isValidAccount(int account) {
        return account >= 1 && account <= n;
    }
}
```
# âš¡ Comprehensive Solution Report: Maximize the Minimum Powered City

---

## ðŸ“‹ Problem Summary

**Inputs**:  
- `stations`: Array of length `n` where `stations[i]` = number of power stations in city `i`
- `r`: Range of each power station (can power cities within distance `r`)
- `k`: Number of additional power stations that can be built optimally

**Power Calculation**:  
City `j`'s power = total number of power stations that can reach it = sum of `stations[i]` for all `i` where `|i - j| <= r`

**Goal**:  
Return the **maximum possible minimum power** across all cities after optimally placing `k` additional power stations

**Output**:  
- Long integer representing maximum minimum power

---

## ðŸ” Key Observations and Constraints

### ðŸŽ¯ Critical Insights:
1. **Binary search on answer**: The problem asks for "maximum possible minimum" which suggests binary search
2. **Monotonic property**: If we can achieve minimum power `x`, we can also achieve any minimum power `< x`
3. **Greedy placement**: When trying to achieve minimum power `x`, place additional stations as far right as possible to cover maximum cities
4. **Sliding window power calculation**: Initial city powers can be calculated using sliding window to avoid O(nÂ²)

### âš ï¸ Constraints Analysis:
- **Large input size**: `n â‰¤ 10âµ`, `stations[i] â‰¤ 10âµ`, so total power can be up to 10Â¹â°
- **Large answer range**: Minimum power can be up to 10Â¹â°, so use `long`
- **Edge cases**:
  - `r = 0`: Each station only powers its own city
  - `r = n-1`: Each station powers all cities
  - `k = 0`: No additional stations, return current minimum power

---

## ðŸ“š Relevant Concepts and Theory

### ðŸ” Binary Search on Answer
Since we want to maximize the minimum power, we can binary search on the answer:
- **Lower bound**: Current minimum power
- **Upper bound**: Current maximum power + k (if we put all k stations in one optimal location)

For each candidate minimum power `mid`, check if it's achievable with `k` stations.

### ðŸ“Š Sliding Window for Initial Power Calculation
Calculate initial city powers efficiently:
- City `i`'s power = sum of `stations[j]` for `j` in `[i-r, i+r]`
- Use sliding window to compute this in O(n) instead of O(nÂ²)

### ðŸŽ¯ Greedy Validation with Difference Array
To check if minimum power `target` is achievable:
1. **Track current power** of each city (including added stations)
2. **Use difference array** to efficiently apply range updates when adding stations
3. **Greedy placement**: When city `i` has insufficient power, add stations at position `min(i + r, n - 1)` to cover maximum future cities

---

## ðŸ§  Logical Analysis

### âŒ Why Direct Simulation Fails:
- **Too many possibilities**: We can place `k` stations in any combination of cities
- **Exponential search space**: Cannot try all possible placements

### âœ… Why Binary Search + Greedy Works:
- **Optimal substructure**: The feasibility function is monotonic
- **Greedy choice property**: Placing stations as far right as possible maximizes coverage for future cities
- **Efficient validation**: Difference array allows O(1) range updates and O(n) validation

### ðŸŽ¯ Key Insight: Difference Array for Range Updates
When we add `x` stations at position `pos`, it affects cities in range `[pos - r, pos + r]`. Using a difference array:
- `diff[pos - r] += x`
- `diff[pos + r + 1] -= x` (if within bounds)
- Prefix sum of `diff` gives actual additions to each city

This allows us to simulate the effect of adding stations in O(1) per addition.

---

## ðŸŽ¯ Effective Strategy

### ðŸ“ Plan:
1. **Calculate initial city powers** using sliding window
2. **Binary search** on answer from `min_power` to `max_power + k`
3. **For each candidate `mid`**:
   - Use difference array to track added power from new stations
   - Iterate through cities left to right
   - If current city power < `mid`, add stations at optimal position
   - Track total stations used
   - If stations used â‰¤ k, candidate is achievable
4. **Return** maximum achievable minimum power

### ðŸ› ï¸ Design Decisions:
- **Sliding window**: O(n) initial power calculation
- **Difference array**: O(1) range updates for station placement
- **Greedy placement**: Always place at `min(i + r, n - 1)` for maximum coverage
- **Long arithmetic**: Handle large power values

---

## ðŸ§ª Illustrative Example Walkthrough

**Example 1**: `stations = [1,2,4,5,0], r = 1, k = 2`

### Step 1: Calculate initial powers
- City 0: stations[0] + stations[1] = 1 + 2 = 3
- City 1: stations[0] + stations[1] + stations[2] = 1 + 2 + 4 = 7
- City 2: stations[1] + stations[2] + stations[3] = 2 + 4 + 5 = 11
- City 3: stations[2] + stations[3] + stations[4] = 4 + 5 + 0 = 9
- City 4: stations[3] + stations[4] = 5 + 0 = 5
- Initial powers: `[3, 7, 11, 9, 5]`
- Current minimum: 3

### Step 2: Binary search range
- Lower bound: 3
- Upper bound: 11 + 2 = 13

### Step 3: Validate candidate = 5
- City 0: power = 3 < 5 â†’ need 2 more
- Place 2 stations at `min(0 + 1, 4) = 1`
- This affects cities [0, 2] â†’ add 2 to each
- New powers: `[5, 9, 13, 9, 5]`
- All â‰¥ 5, used 2 â‰¤ k â†’ achievable âœ…

### Step 4: Try higher candidates...
- Maximum achievable minimum = 5 âœ…

---

## âš¡ Optimal Approach

**Binary Search + Greedy Validation with Difference Array** is optimal because:
- **Time Complexity**: O(n log(max_power))
- **Space Complexity**: O(n)
- **Handles all cases correctly**: Including edge cases and maximum constraints
- **Efficient for large inputs**: Works for n = 10âµ

---

## ðŸ“‹ Step-by-Step Algorithm

1. **Calculate initial powers** using sliding window:
   - Initialize `power[0]` = sum of `stations[0..min(r, n-1)]`
   - For `i = 1 to n-1`: `power[i] = power[i-1] - stations[max(0, i-r-1)] + stations[min(n-1, i+r)]`

2. **Binary search setup**:
   - `left = min(power)`, `right = max(power) + k`

3. **Validation function `canAchieve(target)`**:
   - Initialize `diff` array of zeros
   - Initialize `add = 0` (current additions from difference array)
   - Initialize `used = 0` (stations used)
   - For `i = 0 to n-1`:
     - `add += diff[i]`
     - `currentPower = power[i] + add`
     - If `currentPower < target`:
       - `need = target - currentPower`
       - `used += need`
       - If `used > k`: return false
       - Place at `pos = min(i + r, n - 1)`
       - `add += need`
       - If `pos + r + 1 < n`: `diff[pos + r + 1] -= need`

4. **Binary search**:
   - While `left <= right`:
     - `mid = (left + right) / 2`
     - If `canAchieve(mid)`: `left = mid + 1`
     - Else: `right = mid - 1`

5. **Return** `right`

---

## ðŸ“Š Complexity Analysis

### â±ï¸ Time Complexity: **O(n log(max_power))**
- **Initial power calculation**: O(n)
- **Binary search iterations**: O(log(max_power)) â‰ˆ O(log(10Â¹â°)) â‰ˆ 35
- **Validation per iteration**: O(n)
- **Total**: O(n Ã— 35) â‰ˆ **3.5 million operations** for n = 10âµ âœ…

### ðŸ’¾ Space Complexity: **O(n)**
- **Power array**: O(n)
- **Difference array**: O(n)
- **Total**: O(n)

---

## ðŸ§ª Test Cases

### âœ… Basic Cases
1. **Example 1**: `[1,2,4,5,0], r=1, k=2` â†’ `5`
2. **Example 2**: `[4,4,4,4], r=0, k=3` â†’ `4`

### âš ï¸ Edge Cases
3. **r = 0**: Each station only powers its city
4. **r = n-1**: Each station powers all cities
5. **k = 0**: Return current minimum power
6. **All zeros**: `stations = [0,0,0], r=1, k=5` â†’ optimal placement

---

## ðŸ’» Final Implementation (Java)

```java
/**
 * âš¡ Solution for "Maximize the Minimum Powered City"
 * 
 * Strategy: Binary search on answer + greedy validation with difference array
 * Time Complexity: O(n log(max_power))
 * Space Complexity: O(n)
 */
class Solution {
    
    /**
     * Finds the maximum possible minimum power of a city after optimally
     * placing k additional power stations.
     * 
     * ðŸ§  Key insight: Use binary search on the answer combined with greedy
     * validation. For each candidate minimum power, use a difference array
     * to efficiently simulate the optimal placement of additional stations.
     * 
     * ðŸ” The greedy strategy places stations as far to the right as possible
     * (at min(i + r, n - 1)) to maximize coverage for future cities, which
     * is provably optimal for minimizing the total number of stations needed.
     * 
     * @param stations number of power stations in each city
     * @param r range of each power station
     * @param k number of additional power stations to build
     * @return maximum possible minimum power across all cities
     */
    public long maxPower(int[] stations, int r, int k) {
        int n = stations.length;
        
        // ðŸ“Š Calculate initial power of each city using sliding window
        long[] power = new long[n];
        
        // Initialize first city's power
        long sum = 0;
        for (int i = 0; i <= Math.min(r, n - 1); i++) {
            sum += stations[i];
        }
        power[0] = sum;
        
        // Calculate remaining cities using sliding window
        for (int i = 1; i < n; i++) {
            // Remove leftmost element that's no longer in range
            if (i - r - 1 >= 0) {
                sum -= stations[i - r - 1];
            }
            // Add rightmost element that's now in range
            if (i + r < n) {
                sum += stations[i + r];
            }
            power[i] = sum;
        }
        
        // ðŸŽ¯ Binary search on answer
        long left = 0;
        long right = 0;
        for (long p : power) {
            left = Math.min(left, p);
            right = Math.max(right, p);
        }
        right += k; // Upper bound: max power + all k stations in one place
        
        while (left <= right) {
            long mid = left + (right - left) / 2;
            if (canAchieve(power, r, k, mid)) {
                left = mid + 1;
            } else {
                right = mid - 1;
            }
        }
        
        return right;
    }
    
    /**
     * Checks if it's possible to achieve minimum power 'target' using at most k stations.
     * 
     * ðŸ§  Uses difference array technique for efficient range updates and greedy placement
     * strategy that always places stations as far right as possible to maximize coverage.
     * 
     * @param power initial power of each city
     * @param r range of power stations
     * @param k available additional stations
     * @param target minimum power to achieve
     * @return true if achievable, false otherwise
     */
    private boolean canAchieve(long[] power, int r, int k, long target) {
        int n = power.length;
        long[] diff = new long[n + 1]; // Difference array for range updates
        long add = 0; // Current additions from difference array prefix sum
        long used = 0; // Total stations used
        
        for (int i = 0; i < n; i++) {
            // Apply difference array updates
            add += diff[i];
            
            long currentPower = power[i] + add;
            if (currentPower < target) {
                long need = target - currentPower;
                used += need;
                if (used > k) {
                    return false;
                }
                
                // ðŸŽ¯ Greedy placement: place at farthest right position that still covers city i
                // This maximizes coverage for future cities
                int pos = Math.min(i + r, n - 1);
                add += need;
                
                // Update difference array for range [pos - r, pos + r]
                int rightBound = pos + r + 1;
                if (rightBound < n) {
                    diff[rightBound] -= need;
                }
            }
        }
        
        return true;
    }
}
```
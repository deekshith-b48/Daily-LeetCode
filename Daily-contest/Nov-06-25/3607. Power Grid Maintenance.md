# âš¡ Comprehensive Solution Report: Power Grid Maintenance

---

## ğŸ“‹ Problem Summary

**Inputs**:  
- `c`: Number of power stations (1 to c, 1-based indexing)
- `connections`: 2D array representing bidirectional cables between stations
- `queries`: 2D array where each query is:
  - `[1, x]`: Maintenance check for station x
  - `[2, x]`: Station x goes offline (i.e., becomes non-operational)

**Power Grid Definition**:  
Stations connected directly or indirectly form a power grid (connected components)

**Maintenance Check Logic**:  
For query `[1, x]`:
- If station `x` is **online**, it resolves the check by itself (return `x`)
- If station `x` is **offline**, the check is resolved by the **operational station with the smallest id** in the same power grid
- If **no operational station** exists in that grid, return `-1`

**Key Constraint**:  
Offline stations remain part of their original grid (connectivity doesn't change)

**Goal**:  
Return an array of integers representing the results of each query of type `[1, x]` in order

**Output**:  
- Integer array of query results

---

## ğŸ” Key Observations and Constraints

### ğŸ¯ Critical Insights:
1. **Static connectivity**: Power grids (connected components) never change - only station status changes
2. **Union-Find for components**: Efficiently precompute connected components using DSU (Disjoint Set Union)
3. **Per-component tracking**: For each connected component, maintain a sorted set of online stations
4. **Efficient minimum access**: Use `TreeSet` to get the smallest online station in O(1) time

### âš ï¸ Constraints Analysis:
- **Large input size**: Up to 10âµ stations, 10âµ connections, 2Ã—10âµ queries
- **Offline tracking**: Need efficient way to find smallest online station per component
- **Edge cases**:
  - Isolated stations (no connections)
  - All stations in a component go offline
  - Single station components

---

## ğŸ“š Relevant Concepts and Theory

### ğŸ” Disjoint Set Union (DSU/Union-Find)
DSU efficiently handles the connected components problem:
- **Union operation**: Connects two stations into the same component
- **Find operation**: Determines which component a station belongs to
- **Path compression and union by rank**: Ensures near-constant time complexity

### ğŸ“Š TreeSet for Sorted Online Stations
For each component root, maintain a `TreeSet` of online station IDs:
- **Automatic sorting**: Maintains elements in ascending order
- **O(1) minimum access**: `first()` returns the smallest element
- **O(log n) updates**: Efficient insertion and removal

### ğŸ¯ Key Insight: Static Components + Dynamic Status
The problem separates into two aspects:
1. **Static**: Connected components (computed once with DSU)
2. **Dynamic**: Station online/offline status (updated per query)

This separation allows efficient preprocessing and query handling.

---

## ğŸ§  Logical Analysis

### âœ… Why DSU + TreeSet Works:
- **Efficient component detection**: DSU provides O(Î±(n)) per operation
- **Optimal minimum tracking**: TreeSet provides O(1) access to minimum online station
- **Efficient updates**: O(log n) per station status change
- **Total complexity**: O(connections Ã— Î±(c) + queries Ã— log c) - optimal for constraints

### ğŸ¯ Key Insight: Online Status Tracking
The `online[]` boolean array tracks current status, while `TreeSet` per component tracks only online stations, enabling:
- **Fast check**: `online[x]` for type 1 queries
- **Efficient removal**: Remove from TreeSet when station goes offline
- **Minimum access**: `TreeSet.first()` for offline station queries

---

## ğŸ¯ Effective Strategy

### ğŸ“ Plan:
1. **Initialize DSU** with `c + 1` elements (1-based indexing)
2. **Process connections** using DSU union operations
3. **Initialize online status**: All stations start as online (`true`)
4. **Build component TreeSets**: For each station, add to its root's TreeSet
5. **Process queries**:
   - Type `[1, x]`: Check online status and return appropriate result
   - Type `[2, x]`: Mark station as offline and remove from component TreeSet
6. **Return** results array

### ğŸ› ï¸ Design Decisions:
- **DSU with path compression**: Optimal component detection
- **TreeSet per root**: Efficient minimum tracking
- **Boolean array for status**: O(1) status checks
- **HashMap for component mapping**: Root â†’ TreeSet mapping

---

## ğŸ§ª Illustrative Example Walkthrough

**Example 1**: `c = 5, connections = [[1,2],[2,3],[3,4],[4,5]], queries = [[1,3],[2,1],[1,1],[2,2],[1,2]]`

### Step 1: DSU Initialization
- All stations initially in separate components: `{1}, {2}, {3}, {4}, {5}`

### Step 2: Process Connections
- After all unions: single component with root (say) `1`
- `dsu.find(i) = 1` for all `i = 1..5`

### Step 3: Build Component TreeSet
- `componentMin[1] = {1,2,3,4,5}`
- `online = [false, true, true, true, true, true]` (1-based)

### Step 4: Process Queries

**Query [1,3]**:
- `online[3] = true` â†’ return `3` âœ…

**Query [2,1]**:
- Set `online[1] = false`
- Remove `1` from `componentMin[1]` â†’ `{2,3,4,5}`

**Query [1,1]**:
- `online[1] = false`
- `componentMin[1].first() = 2` â†’ return `2` âœ…

**Query [2,2]**:
- Set `online[2] = false`
- Remove `2` from `componentMin[1]` â†’ `{3,4,5}`

**Query [1,2]**:
- `online[2] = false`
- `componentMin[1].first() = 3` â†’ return `3` âœ…

**Output**: `[3,2,3]` âœ…

**Example 2**: `c = 3, connections = [], queries = [[1,1],[2,1],[1,1]]`

### Step 1-2: DSU remains separate components
- `dsu.find(1) = 1`, `dsu.find(2) = 2`, `dsu.find(3) = 3`

### Step 3: Component TreeSets
- `componentMin[1] = {1}`, `componentMin[2] = {2}`, `componentMin[3] = {3}`

### Step 4: Process Queries
**Query [1,1]**: `online[1] = true` â†’ return `1`
**Query [2,1]**: Set `online[1] = false`, remove `1` from `componentMin[1]` â†’ `{}`
**Query [1,1]**: `online[1] = false`, `componentMin[1]` empty â†’ return `-1`

**Output**: `[1,-1]` âœ…

---

## âš¡ Optimal Approach

**DSU + TreeSet per Component** is optimal because:
- **Time Complexity**: O(connections Ã— Î±(c) + queries Ã— log c)
- **Space Complexity**: O(c + connections)
- **Handles all cases correctly**: Including edge cases and maximum constraints
- **Efficient for large inputs**: Works for maximum constraints

---

## ğŸ“‹ Step-by-Step Algorithm

1. **Initialize DSU** with `c + 1` elements (1-based indexing)
2. **Union all connections** using DSU
3. **Initialize online array** with all `true`
4. **Build component TreeSets**:
   - For each station `i` from 1 to c:
     - Find root = `dsu.find(i)`
     - Add `i` to `componentMin[root]`
5. **Process each query**:
   - Type 1: Check online status and return appropriate result
   - Type 2: Mark offline and remove from component TreeSet
6. **Convert result list to array** and return

---

## ğŸ“Š Complexity Analysis

### â±ï¸ Time Complexity: **O(connections Ã— Î±(c) + queries Ã— log c)**
- **DSU initialization**: O(c)
- **Union operations**: O(connections Ã— Î±(c)) where Î± is inverse Ackermann
- **TreeSet initialization**: O(c log c)
- **Query processing**: O(queries Ã— log c)
- **Total**: Effectively O(connections + queries Ã— log c) âœ…

### ğŸ’¾ Space Complexity: **O(c)**
- **DSU arrays**: O(c)
- **Online array**: O(c)
- **TreeSets**: O(c)
- **HashMap**: O(c)
- **Total**: O(c)

---

## ğŸ§ª Test Cases

### âœ… Basic Cases
1. **Example 1**: `c=5, connections=[[1,2],[2,3],[3,4],[4,5]], queries=[[1,3],[2,1],[1,1],[2,2],[1,2]]` â†’ `[3,2,3]`
2. **Example 2**: `c=3, connections=[], queries=[[1,1],[2,1],[1,1]]` â†’ `[1,-1]`

### âš ï¸ Edge Cases
3. **All isolated stations**: Each station is its own component
4. **Single component with all stations offline**: Returns `-1` for all queries
5. **Mixed online/offline**: Properly handles complex status combinations

---

## ğŸ’» Final Implementation (Java)

```java
import java.util.*;

/**
 * âš¡ Solution for "Power Grid Maintenance"
 * 
 * Strategy: DSU for connected components + TreeSet per component for online stations
 * Time Complexity: O(connections * Î±(c) + queries * log c)
 * Space Complexity: O(c)
 */
class Solution {
    
    /**
     * Processes power grid maintenance queries.
     * 
     * ğŸ§  Key insight: Use DSU to precompute connected components, then maintain
     * a TreeSet of online stations for each component root. This allows O(1)
     * access to the smallest online station and O(log c) updates.
     * 
     * ğŸ” The algorithm efficiently separates static connectivity (DSU) from
     * dynamic status changes (online/offline tracking with boolean array and TreeSets).
     * 
     * @param c number of power stations (1 to c, 1-based)
     * @param connections bidirectional cables between stations
     * @param queries maintenance [1,x] and offline [2,x] queries
     * @return results of all type [1,x] queries in order
     */
    public int[] processQueries(int c, int[][] connections, int[][] queries) {
        // ğŸ§© Initialize DSU with 1-based indexing (0 unused)
        DSU dsu = new DSU(c + 1);
        
        // ğŸ”— Process all connections to build connected components
        for (int[] conn : connections) {
            dsu.union(conn[0], conn[1]);
        }
        
        // ğŸŸ¢ Initialize online status: all stations start as online
        boolean[] online = new boolean[c + 1];
        Arrays.fill(online, true);
        
        // ğŸŒ³ For each component root, maintain TreeSet of online stations
        Map<Integer, TreeSet<Integer>> componentMin = new HashMap<>();
        for (int i = 1; i <= c; i++) {
            int root = dsu.find(i);
            componentMin.computeIfAbsent(root, k -> new TreeSet<>()).add(i);
        }
        
        // ğŸ”„ Process all queries
        List<Integer> result = new ArrayList<>();
        for (int[] query : queries) {
            int type = query[0];
            int x = query[1];
            
            if (type == 1) {
                // ğŸ› ï¸ Maintenance check query
                if (online[x]) {
                    // Station is online - resolves by itself
                    result.add(x);
                } else {
                    // Station is offline - find smallest online in same component
                    int root = dsu.find(x);
                    TreeSet<Integer> set = componentMin.get(root);
                    if (set == null || set.isEmpty()) {
                        // No online stations in component
                        result.add(-1);
                    } else {
                        // Return smallest online station
                        result.add(set.first());
                    }
                }
            } else if (type == 2) {
                // âš¡ Station goes offline
                if (online[x]) {
                    online[x] = false;
                    int root = dsu.find(x);
                    TreeSet<Integer> set = componentMin.get(root);
                    if (set != null) {
                        set.remove(x);
                    }
                }
            }
        }
        
        // ğŸ“¤ Convert result list to array
        int[] resArray = new int[result.size()];
        for (int i = 0; i < resArray.length; i++) {
            resArray[i] = result.get(i);
        }
        return resArray;
    }
    
    /**
     * ğŸ§© Disjoint Set Union (DSU) implementation with path compression and union by rank.
     * 
     * Provides efficient connected components operations with near-constant time complexity.
     */
    static class DSU {
        int[] parent;
        int[] rank;
        
        /**
         * Initializes DSU with n elements (0 to n-1).
         * 
         * @param n number of elements
         */
        public DSU(int n) {
            parent = new int[n];
            rank = new int[n];
            for (int i = 0; i < n; i++) {
                parent[i] = i;
            }
        }
        
        /**
         * Finds the root of element x with path compression.
         * 
         * @param x element to find root for
         * @return root of x
         */
        public int find(int x) {
            if (parent[x] != x) {
                parent[x] = find(parent[x]);
            }
            return parent[x];
        }
        
        /**
         * Unions the sets containing x and y with union by rank.
         * 
         * @param x first element
         * @param y second element
         */
        public void union(int x, int y) {
            int xRoot = find(x);
            int yRoot = find(y);
            if (xRoot == yRoot) {
                return;
            }
            if (rank[xRoot] < rank[yRoot]) {
                parent[xRoot] = yRoot;
            } else {
                parent[yRoot] = xRoot;
                if (rank[xRoot] == rank[yRoot]) {
                    rank[xRoot]++;
                }
            }
        }
    }
}
```
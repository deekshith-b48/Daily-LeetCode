# ğŸ›¡ï¸ Comprehensive Solution Report: Count Unguarded Cells in the Grid

---

## ğŸ“‹ Problem Summary

**Inputs**:  
- `m`, `n`: Dimensions of an `m Ã— n` grid (1 â‰¤ m, n â‰¤ 10âµ, 2 â‰¤ mÃ—n â‰¤ 10âµ)
- `guards`: 2D array where `guards[i] = [rowi, coli]` representing guard positions
- `walls`: 2D array where `walls[j] = [rowj, colj]` representing wall positions

**Guard Visibility**:  
A guard can see every cell in the four cardinal directions (north, east, south, west) until blocked by a wall or another guard.

**Goal**:  
Return the **number of unoccupied cells that are not guarded** (i.e., cells that are neither occupied by a guard nor a wall, and not visible to any guard)

**Output**:  
- Single integer representing count of unguarded cells

---

## ğŸ” Key Observations and Constraints

### ğŸ¯ Critical Insights:
1. **Grid size is large**: Up to 10âµ cells, so we need an efficient approach
2. **Guard visibility is directional**: Each guard "shoots" rays in 4 directions until blocked
3. **Obstruction rules**: Guards and walls block visibility
4. **Cell types**: 
   - Guard cells: occupied, but also emit visibility
   - Wall cells: occupied, block visibility
   - Empty cells: can be guarded or unguarded
5. **No overlap**: All guard and wall positions are unique

### âš ï¸ Constraints Analysis:
- **Large grid**: But total cells â‰¤ 10âµ, so we can iterate over all cells if needed
- **Many guards/walls**: Up to 5Ã—10â´ each, so we need to avoid O(guards Ã— cells) approaches
- **Edge cases**:
  - No guards â†’ all empty cells are unguarded
  - No walls â†’ guards can see far
  - Guards on borders

---

## ğŸ“š Relevant Concepts and Theory

### ğŸ” Simulation with Directional Propagation
The most straightforward approach is to:
1. **Mark all guard and wall positions** in a 2D boolean grid
2. **For each guard**, propagate visibility in 4 directions until hitting a wall or guard
3. **Count unguarded cells**: Cells that are not occupied and not marked as guarded

### ğŸ“Š Optimization: Early Termination
Since we only care about whether a cell is guarded (not how many guards see it), we can:
- Use a `visited` or `isGuarded` 2D boolean array
- For each guard, mark cells in 4 directions until blocked
- Skip marking if already marked (optional optimization)

### ğŸ¯ Key Insight: Directional Ray Casting
Each guard casts 4 "rays" (up, down, left, right). We simulate these rays and mark cells as guarded.

---

## ğŸ§  Logical Analysis

### âœ… Why Direct Simulation Works:
- **Total cells â‰¤ 10âµ**: Even if we simulate all guard rays, the total work is bounded
- **Ray propagation**: Each ray stops at first obstruction, so total operations is proportional to grid size
- **Simple implementation**: Easy to understand and debug

### ğŸ¯ Key Insight: Marking Strategy
We can use a 2D boolean array `guarded` to track which cells are visible to at least one guard. Then count cells that are:
- Not occupied by guard or wall
- Not marked as guarded

---

## ğŸ¯ Effective Strategy

### ğŸ“ Plan:
1. **Create 2D arrays**:
   - `isGuard` to mark guard positions
   - `isWall` to mark wall positions
   - `isGuarded` to mark cells visible to guards
2. **Mark guard and wall positions**
3. **For each guard**, simulate 4-directional propagation:
   - In each direction, mark cells as guarded until hitting a wall or guard
4. **Count unguarded cells**: Cells that are not occupied and not guarded
5. **Return** the count

### ğŸ› ï¸ Design Decisions:
- **Boolean arrays**: Simple and efficient for marking
- **Direction vectors**: Use dx, dy arrays for clean code
- **Early termination**: Stop ray propagation when hitting obstruction

---

## ğŸ§ª Illustrative Example Walkthrough

**Example 1**: `m = 4, n = 6, guards = [[0,0],[1,1],[2,3]], walls = [[0,1],[2,2],[1,4]]`

### Step 1: Mark positions
- `isGuard[0][0] = true`, `isGuard[1][1] = true`, `isGuard[2][3] = true`
- `isWall[0][1] = true`, `isWall[2][2] = true`, `isWall[1][4] = true`

### Step 2: Simulate guard rays

**Guard at (0,0)**:
- Right: (0,1) is wall â†’ stop
- Down: (1,0), (2,0), (3,0) â†’ mark as guarded
- Left: out of bounds
- Up: out of bounds

**Guard at (1,1)**:
- Right: (1,2), (1,3) â†’ (1,4) is wall â†’ stop
- Down: (2,1), (3,1) â†’ mark as guarded
- Left: (1,0) â†’ mark as guarded
- Up: (0,1) is wall â†’ stop

**Guard at (2,3)**:
- Right: (2,4), (2,5) â†’ mark as guarded
- Down: (3,3) â†’ mark as guarded
- Left: (2,2) is wall â†’ stop
- Up: (1,3), (0,3) â†’ mark as guarded

### Step 3: Count unguarded cells
- Total cells: 24
- Occupied cells: 3 guards + 3 walls = 6
- Guarded cells: 11 (from simulation)
- Unguarded cells: 24 - 6 - 11 = 7 âœ…

---

## âš¡ Optimal Approach

**Direct Simulation with Directional Propagation** is optimal because:
- **Time Complexity**: O(m Ã— n) in worst case, but typically much better due to early termination
- **Space Complexity**: O(m Ã— n) for marking arrays
- **Handles all cases correctly**: Including edge cases and maximum constraints
- **Simple and reliable**: Easy to implement and verify

---

## ğŸ“‹ Step-by-Step Algorithm

1. **Initialize** 2D boolean arrays for `isGuard`, `isWall`, `isGuarded`
2. **Mark guard and wall positions**
3. **For each guard position**:
   - For each of 4 directions:
     - Start from guard position
     - Move in direction until out of bounds or hit wall/guard
     - Mark each cell as guarded
4. **Count unguarded cells**:
   - For each cell (i,j):
     - If not occupied (not guard or wall) and not guarded â†’ increment count
5. **Return** the count

---

## ğŸ“Š Complexity Analysis

### â±ï¸ Time Complexity: **O(m Ã— n)**
- **Initialization**: O(m Ã— n) for creating arrays
- **Marking guards/walls**: O(guards + walls)
- **Ray propagation**: In worst case, each guard might scan entire row/column, but total work is bounded by grid size
- **Counting**: O(m Ã— n)
- **Total**: O(m Ã— n)

### ğŸ’¾ Space Complexity: **O(m Ã— n)**
- **Three 2D boolean arrays**: 3 Ã— m Ã— n
- **Total**: O(m Ã— n)

---

## ğŸ§ª Test Cases

### âœ… Basic Cases
1. **Example 1**: `m=4, n=6, guards=[[0,0],[1,1],[2,3]], walls=[[0,1],[2,2],[1,4]]` â†’ `7`
2. **Example 2**: `m=3, n=3, guards=[[1,1]], walls=[[0,1],[1,0],[2,1],[1,2]]` â†’ `4`

### âš ï¸ Edge Cases
3. **No guards**: All empty cells are unguarded
4. **No walls**: Guards can see far, few unguarded cells
5. **All cells occupied**: 0 unguarded cells
6. **Single guard**: Only cells in its line of sight are guarded

---

## ğŸ’» Final Implementation (Java)

```java
/**
 * ğŸ›¡ï¸ Solution for "Count Unguarded Cells in the Grid"
 * 
 * Strategy: Direct simulation with directional propagation
 * Time Complexity: O(m Ã— n)
 * Space Complexity: O(m Ã— n)
 */
class Solution {
    
    /**
     * Counts the number of unguarded cells in the grid.
     * 
     * ğŸ§  Key insight: Mark all guard and wall positions, then simulate each guard's
     * 4-directional visibility rays. A cell is unguarded if it's not occupied and
     * not visible to any guard.
     * 
     * ğŸ” The algorithm uses three 2D boolean arrays to track:
     * - isGuard: positions of guards
     * - isWall: positions of walls
     * - isGuarded: cells visible to at least one guard
     * 
     * @param m number of rows
     * @param n number of columns
     * @param guards 2D array of guard positions
     * @param walls 2D array of wall positions
     * @return number of unguarded cells
     */
    public int countUnguarded(int m, int n, int[][] guards, int[][] walls) {
        // ğŸ“‹ Create 2D boolean arrays for tracking
        boolean[][] isGuard = new boolean[m][n];
        boolean[][] isWall = new boolean[m][n];
        boolean[][] isGuarded = new boolean[m][n];
        
        // ğŸ¯ Mark guard and wall positions
        for (int[] guard : guards) {
            isGuard[guard[0]][guard[1]] = true;
        }
        for (int[] wall : walls) {
            isWall[wall[0]][wall[1]] = true;
        }
        
        // ğŸ“ Define 4 directions: up, right, down, left
        int[] dx = {-1, 0, 1, 0};
        int[] dy = {0, 1, 0, -1};
        
        // ğŸ” For each guard, simulate 4-directional propagation
        for (int[] guard : guards) {
            int x = guard[0], y = guard[1];
            
            // ğŸ”„ Try all 4 directions
            for (int d = 0; d < 4; d++) {
                int nx = x + dx[d];
                int ny = y + dy[d];
                
                // ğŸš« Propagate in this direction until hitting boundary or obstruction
                while (nx >= 0 && nx < m && ny >= 0 && ny < n) {
                    // ğŸ›‘ Stop if we hit a wall or another guard
                    if (isWall[nx][ny] || isGuard[nx][ny]) {
                        break;
                    }
                    
                    // âœ… Mark this cell as guarded
                    isGuarded[nx][ny] = true;
                    
                    // ğŸ”„ Move to next cell in this direction
                    nx += dx[d];
                    ny += dy[d];
                }
            }
        }
        
        // ğŸ§® Count unguarded cells
        int unguardedCount = 0;
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                // ğŸŸ¢ Cell is unguarded if:
                // 1. It's not occupied by guard or wall
                // 2. It's not marked as guarded
                if (!isGuard[i][j] && !isWall[i][j] && !isGuarded[i][j]) {
                    unguardedCount++;
                }
            }
        }
        
        return unguardedCount;
    }
}
```
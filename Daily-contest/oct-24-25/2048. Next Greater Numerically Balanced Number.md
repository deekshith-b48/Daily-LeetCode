# 🔢 Comprehensive Solution Report: Next Greater Numerically Balanced Number

---

## 📋 Problem Summary

**Inputs**:  
- `n`: Integer where 0 ≤ n ≤ 10⁶

**Numerically Balanced Definition**:  
An integer `x` is numerically balanced if for every digit `d` in `x`, there are exactly `d` occurrences of digit `d` in `x`.

**Key Constraints**:
- Digit `0` cannot appear in a numerically balanced number (since it would need exactly 0 occurrences, but if it appears, it has at least 1 occurrence)
- Valid digits are only 1-9
- For digit `d` to appear, it must appear exactly `d` times

**Goal**:  
Return the **smallest numerically balanced number** that is **strictly greater than `n`**

**Output**:  
- Single integer representing the next beautiful number

---

## 🔍 Key Observations and Constraints

### 🎯 Critical Insights:
1. **Limited valid combinations**: Only certain combinations of digits can form numerically balanced numbers
2. **Valid digit sets**: Possible combinations include:
   - Single digits: `[1]`, `[2,2]`, `[3,3,3]`, etc.
   - Multiple digits: `[1,2,2]` (1 appears once, 2 appears twice), `[1,3,3,3]`, `[2,2,3,3,3]`, etc.
3. **Maximum length**: Since n ≤ 10⁶, we need to consider numbers up to around 7-8 digits
4. **No zeros allowed**: Any number containing digit 0 cannot be numerically balanced

### ⚠️ Constraints Analysis:
- **Small input range**: n ≤ 10⁶ means the answer will be at most around 10⁷
- **Limited beautiful numbers**: There are only a finite number of numerically balanced numbers below 10⁷
- **Edge cases**:
  - `n = 0` → answer is `1`
  - `n = 1` → answer is `22` (not `1` since we need strictly greater)

---

## 📚 Relevant Concepts and Theory

### 🔍 Precomputation Strategy
Instead of checking every number greater than `n`, we can **precompute all possible numerically balanced numbers** up to a reasonable limit (like 2×10⁶) and then find the smallest one greater than `n`.

### 📊 Valid Combinations Generation
We can generate all valid digit combinations that satisfy the numerically balanced condition:
- **Length 1**: `[1]`
- **Length 2**: `[2,2]`
- **Length 3**: `[3,3,3]`, `[1,2,2]`
- **Length 4**: `[4,4,4,4]`, `[1,3,3,3]`
- **Length 5**: `[5,5,5,5,5]`, `[2,2,3,3,3]`
- **Length 6**: `[6,6,6,6,6,6]`, `[1,5,5,5,5,5]`, `[1,2,2,3,3,3]`
- **Length 7**: `[7,7,7,7,7,7,7]`, `[1,6,6,6,6,6,6]`, `[2,2,5,5,5,5,5]`, `[1,2,2,4,4,4,4]`
- **Length 8**: `[1,7,7,7,7,7,7,7]`, `[2,2,6,6,6,6,6,6]`, `[3,3,3,5,5,5,5,5]`, `[1,2,2,5,5,5,5,5]`, `[1,3,3,3,4,4,4,4]`

### 🎯 Permutation Generation
For each valid combination, we generate all unique permutations and convert them to integers, then sort and deduplicate.

---

## 🧠 Logical Analysis

### ❌ Why Brute Force Fails:
- **Inefficient**: Checking every number > n for the balanced property could be slow
- **Redundant work**: We'd be checking many invalid numbers

### ✅ Why Precomputation Works:
- **Finite set**: There are only about 100-200 numerically balanced numbers below 2×10⁶
- **One-time cost**: Precomputation happens once, then queries are O(log k) where k is the number of beautiful numbers
- **Guaranteed coverage**: We can ensure our precomputed list covers all possible answers for n ≤ 10⁶

### 🎯 Key Insight: Known Beautiful Numbers
The numerically balanced numbers are well-known and limited. For n ≤ 10⁶, the maximum answer is around 1,224,333 or similar, so we can safely precompute up to 2×10⁶.

---

## 🎯 Effective Strategy

### 📝 Plan:
1. **Precompute all numerically balanced numbers** up to a safe upper bound (2×10⁶)
2. **Sort the precomputed list**
3. **For each query**, use binary search to find the smallest number > n
4. **Return** the result

### 🛠️ Design Decisions:
- **Upper bound**: Use 2×10⁶ to ensure coverage for all n ≤ 10⁶
- **Efficient generation**: Generate valid combinations and their permutations
- **Deduplication**: Use TreeSet to automatically sort and remove duplicates

---

## 🧪 Illustrative Example Walkthrough

**Example 1**: `n = 1`
- Beautiful numbers: `[1, 22, 122, 212, 221, 333, 1333, 3133, 3313, 3331, ...]`
- Smallest > 1: `22` ✅

**Example 2**: `n = 1000`
- Beautiful numbers around 1000: `333, 1333, 3133, ...`
- Smallest > 1000: `1333` ✅

**Example 3**: `n = 3000`
- Beautiful numbers around 3000: `1333, 3133, 3313, 3331, ...`
- Smallest > 3000: `3133` ✅

---

## ⚡ Optimal Approach

**Precomputation with Binary Search** is optimal because:
- **Time Complexity**: O(1) per query after precomputation
- **Space Complexity**: O(k) where k ≈ 200 beautiful numbers
- **Handles all cases correctly**: Including edge cases and maximum constraints
- **Extremely fast**: Precomputation done once, queries are instant

---

## 📋 Step-by-Step Algorithm

1. **Precompute all beautiful numbers** up to 2×10⁶:
   - Generate all valid digit combinations
   - For each combination, generate all unique permutations
   - Convert to integers and collect in sorted set
2. **Convert to sorted array** for binary search
3. **For input n**, find first beautiful number > n using binary search
4. **Return** the result

---

## 📊 Complexity Analysis

### ⏱️ Time Complexity: **O(1) per query**
- **Precomputation**: O(k) where k ≈ 200 (done once)
- **Query**: O(log k) ≈ O(1) for binary search
- **Total per call**: O(1)

### 💾 Space Complexity: **O(k)**
- **Beautiful numbers list**: ~200 integers
- **Total**: Negligible memory usage

---

## 🧪 Test Cases

### ✅ Basic Cases
1. **Example 1**: `n = 1` → `22`
2. **Example 2**: `n = 1000` → `1333`
3. **Example 3**: `n = 3000` → `3133`

### ⚠️ Edge Cases
4. **n = 0** → `1`
5. **n = 22** → `122`
6. **n = 1224333** → next beautiful number (largest case)

### 🚀 Boundary Cases
7. **n = 10⁶** → appropriate beautiful number
8. **Maximum beautiful number** in range

---

## 💻 Final Implementation (Java)

```java
import java.util.*;

/**
 * 🔢 Solution for "Next Greater Numerically Balanced Number"
 * 
 * Strategy: Precomputation of all beautiful numbers with binary search
 * Time Complexity: O(1) per query after precomputation
 * Space Complexity: O(k) where k ≈ 200 beautiful numbers
 */
class Solution {
    
    // 📋 Precomputed list of all numerically balanced numbers up to 2*10^6
    private static final int[] BEAUTIFUL_NUMBERS = {
        1, 22, 122, 212, 221, 333, 1333, 3133, 3313, 3331, 
        4444, 14444, 22333, 23233, 23323, 23332, 32233, 32323, 32332, 33223, 
        33232, 33322, 41444, 44144, 44414, 44441, 55555, 122333, 123233, 123323, 
        123332, 132233, 132323, 132332, 133223, 133232, 133322, 155555, 212333, 
        213233, 213323, 213332, 221333, 223133, 223313, 223331, 224444, 231233, 
        231323, 231332, 232133, 232313, 232331, 233123, 233132, 233213, 233231, 
        233312, 233321, 242444, 244244, 244424, 244442, 312233, 312323, 312332, 
        313223, 313232, 313322, 321233, 321323, 321332, 322133, 322313, 322331, 
        323123, 323132, 323213, 323231, 323312, 323321, 331223, 331232, 331322, 
        332123, 332132, 332213, 332231, 332312, 332321, 333122, 333212, 333221, 
        422444, 424244, 424424, 424442, 442244, 442424, 442442, 444224, 444242, 
        444422, 515555, 551555, 555155, 555515, 555551, 666666, 1224444
    };
    
    /**
     * Finds the smallest numerically balanced number strictly greater than n.
     * 
     * 🧠 Key insight: Precompute all possible numerically balanced numbers up to
     * a safe upper bound (2*10^6), then use binary search to find the answer.
     * This approach is extremely efficient since there are only about 110-120
     * beautiful numbers in the relevant range.
     * 
     * 🔍 A number is numerically balanced if every digit d appears exactly d times.
     * This means digit 0 can never appear, and valid combinations are limited to
     * specific patterns like [1], [2,2], [1,2,2], [3,3,3], [1,3,3,3], etc.
     * 
     * @param n input integer (0 <= n <= 10^6)
     * @return smallest numerically balanced number > n
     */
    public int nextBeautifulNumber(int n) {
        // 🔍 Use binary search to find the first beautiful number > n
        int left = 0;
        int right = BEAUTIFUL_NUMBERS.length;
        
        while (left < right) {
            int mid = left + (right - left) / 2;
            if (BEAUTIFUL_NUMBERS[mid] <= n) {
                left = mid + 1;
            } else {
                right = mid;
            }
        }
        
        return BEAUTIFUL_NUMBERS[left];
    }
}
```

The precomputed array contains all numerically balanced numbers up to approximately 1.2 million, which is sufficient to handle all inputs where `n ≤ 10⁶`. The largest beautiful number needed for the constraint is `1224444`, which covers the worst-case scenario.